import pygame
import sys
import os
import random
import math
import json
from enum import Enum
import collections  # Para optimizar partículas

# Inicializar Pygame
pygame.init()

# Configuración de pantalla completa
ventana = pygame.display.set_mode((0, 0), pygame.FULLSCREEN)
ANCHO, ALTO = ventana.get_size()
pygame.display.set_caption("Stick Man Arena - V0.2")

# Inicializar mixer de pygame para sonido
pygame.mixer.init(frequency=22050, size=-16, channels=2, buffer=512)

clock = pygame.time.Clock()

# Estados del juego
MENU = "menu"
SELECCION_MODO = "seleccion_modo"
SELECCION_PERSONAJE = "seleccion_personaje"
JUGANDO = "jugando"
GAME_OVER = "game_over"
ESTADISTICAS = "estadisticas"
OPCIONES = "opciones"


# Modos de juego
class ModoJuego(Enum):
    CLASICO = "clasico"
    SUPERVIVENCIA = "supervivencia"
    COMBOS_INFINITOS = "combos_infinitos"


# Clases de personaje
CLASES_PERSONAJE = {
    "guerrero": {
        "nombre": "Guerrero",
        "vida": 120,
        "velocidad": 8,
        "dano_base": 12,
        "color": (100, 150, 255),
        "habilidad": "golpe_cargado",
        "descripcion": "Balanceado entre ataque y defensa",
        "bonus_nivel": {"vida": 5, "dano": 0.5, "velocidad": 0.1}
    },
    "asesino": {
        "nombre": "Asesino",
        "vida": 80,
        "velocidad": 12,
        "dano_base": 15,
        "color": (255, 100, 100),
        "habilidad": "dash_ataque",
        "descripcion": "Rápido y letal, pero frágil",
        "bonus_nivel": {"vida": 3, "dano": 0.8, "velocidad": 0.3}
    },
    "tanque": {
        "nombre": "Tanque",
        "vida": 160,
        "velocidad": 6,
        "dano_base": 10,
        "color": (100, 255, 100),
        "habilidad": "bloqueo_fuerte",
        "descripcion": "Alta resistencia, baja movilidad",
        "bonus_nivel": {"vida": 8, "dano": 0.3, "velocidad": 0.05}
    },
    "mago": {
        "nombre": "Mago",
        "vida": 90,
        "velocidad": 7,
        "dano_base": 14,
        "color": (200, 100, 255),
        "habilidad": "rayo_energia",
        "descripcion": "Ataques a distancia y efectos especiales",
        "bonus_nivel": {"vida": 4, "dano": 0.7, "velocidad": 0.2}
    }
}

# Configuración de modos de juego
CONFIG_MODOS = {
    ModoJuego.CLASICO: {
        "nombre": "Modo Clásico",
        "vida_base": 100,
        "dano": [10, 15, 20],
        "powerups": False,
        "habilidades": False,
        "combos_sin_limite": False,
        "descripcion": "Combate tradicional 1vs1",
        "multiplicador_exp": 1.0
    },
    ModoJuego.SUPERVIVENCIA: {
        "nombre": "Supervivencia",
        "vida_base": 50,
        "dano": [15, 20, 25],
        "powerups": True,
        "habilidades": True,
        "combos_sin_limite": False,
        "descripcion": "Sobrevive a oleadas de enemigos cada vez más difíciles",
        "multiplicador_exp": 1.5,
        "oleadas": True
    },
    ModoJuego.COMBOS_INFINITOS: {
        "nombre": "Combos Infinitos",
        "vida_base": 120,
        "dano": [8, 12, 16],
        "powerups": True,
        "combos_sin_limite": True,
        "descripcion": "Combos ilimitados y más vida - ¡Los ataques nunca se resetean!",
        "multiplicador_exp": 1.2
    }
}

# Habilidades que se desbloquean por nivel
HABILIDADES_POR_NIVEL = {
    2: ["dash_mejorado"],
    3: ["defensa_mejorada"],
    4: ["contraataque"],
    5: ["carga_rapida"],
    6: ["super_armor"],
    7: ["regeneracion"],
    8: ["dano_critico"],
    9: ["velocidad_maxima"],
    10: ["habilidad_maestra"]
}


# =============================================================================
# SISTEMA DE PROGRESIÓN
# =============================================================================

class SistemaProgresion:
    def __init__(self):
        self.archivo_progresion = "progresion.json"
        self.progresion = self.cargar_progresion()

    def cargar_progresion(self):
        try:
            with open(self.archivo_progresion, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            progresion_default = {
                "niveles_global": 1,
                "experiencia_global": 0,
                "personajes": {},
                "logros_desbloqueados": [],
                "partidas_jugadas": 0,
                "victorias_totales": 0,
                "mejor_combo_global": 0
            }

            for clase in CLASES_PERSONAJE.keys():
                progresion_default["personajes"][clase] = {
                    "nivel": 1,
                    "experiencia": 0,
                    "habilidades_desbloqueadas": ["base"],
                    "victorias": 0,
                    "partidas_jugadas": 0,
                    "mejor_combo": 0
                }

            self.guardar_progresion(progresion_default)
            return progresion_default

    def guardar_progresion(self, progresion=None):
        if progresion is None:
            progresion = self.progresion

        try:
            with open(self.archivo_progresion, 'w') as f:
                json.dump(progresion, f, indent=4)
        except Exception as e:
            print(f"❌ Error guardando progresión: {e}")

    def calcular_exp_para_nivel(self, nivel):
        return 100 * (nivel ** 1.5)

    def ganar_experiencia_personaje(self, clase, experiencia_ganada, combo_maximo=0, victoria=False):
        if clase not in self.progresion["personajes"]:
            self.progresion["personajes"][clase] = {
                "nivel": 1,
                "experiencia": 0,
                "habilidades_desbloqueadas": ["base"],
                "victorias": 0,
                "partidas_jugadas": 0,
                "mejor_combo": 0
            }

        personaje = self.progresion["personajes"][clase]
        personaje["experiencia"] += experiencia_ganada
        personaje["partidas_jugadas"] += 1

        if victoria:
            personaje["victorias"] += 1
            self.progresion["victorias_totales"] += 1

        if combo_maximo > personaje["mejor_combo"]:
            personaje["mejor_combo"] = combo_maximo
        if combo_maximo > self.progresion["mejor_combo_global"]:
            self.progresion["mejor_combo_global"] = combo_maximo

        exp_necesaria = self.calcular_exp_para_nivel(personaje["nivel"])
        if personaje["experiencia"] >= exp_necesaria:
            return self.subir_nivel_personaje(clase)

        return False

    def subir_nivel_personaje(self, clase):
        personaje = self.progresion["personajes"][clase]
        personaje["nivel"] += 1
        personaje["experiencia"] = 0

        habilidades_nuevas = HABILIDADES_POR_NIVEL.get(personaje["nivel"], [])
        for habilidad in habilidades_nuevas:
            if habilidad not in personaje["habilidades_desbloqueadas"]:
                personaje["habilidades_desbloqueadas"].append(habilidad)

        logro = f"nivel_{personaje['nivel']}_{clase}"
        if logro not in self.progresion["logros_desbloqueados"]:
            self.progresion["logros_desbloqueados"].append(logro)

        self.guardar_progresion()
        return True

    def obtener_habilidades_desbloqueadas(self, clase):
        if clase in self.progresion["personajes"]:
            return self.progresion["personajes"][clase]["habilidades_desbloqueadas"]
        return ["base"]

    def obtener_estadisticas_personaje(self, clase):
        if clase in self.progresion["personajes"]:
            return self.progresion["personajes"][clase]
        return None

    def desbloquear_logro(self, logro_id):
        if logro_id not in self.progresion["logros_desbloqueados"]:
            self.progresion["logros_desbloqueados"].append(logro_id)
            self.guardar_progresion()
            return True
        return False


# =============================================================================
# SISTEMA DE CONFIGURACIÓN
# =============================================================================

class SistemaConfiguracion:
    def __init__(self):
        self.config = {
            "graficos": {
                "pantalla_completa": True,
                "resolucion": "auto",
                "particulas": True,
                "efectos_camara": True,
                "limite_fps": 60
            },
            "audio": {
                "volumen_master": 0.8,
                "volumen_musica": 0.6,
                "volumen_efectos": 0.7,
                "sonidos_activados": True
            },
            "controles": {
                "jugador1": {
                    "izquierda": pygame.K_LEFT,
                    "derecha": pygame.K_RIGHT,
                    "arriba": pygame.K_UP,
                    "ataque_rapido": pygame.K_SPACE,
                    "ataque_pesado": pygame.K_LSHIFT,
                    "habilidad": pygame.K_q,
                    "bloqueo": pygame.K_x
                },
                "jugador2": {
                    "izquierda": pygame.K_a,
                    "derecha": pygame.K_d,
                    "arriba": pygame.K_w,
                    "ataque_rapido": pygame.K_f,
                    "ataque_pesado": pygame.K_r,
                    "habilidad": pygame.K_e,
                    "bloqueo": pygame.K_g
                }
            },
            "gameplay": {
                "dificultad": "normal",
                "tutorial": True,
                "mostrar_hitboxes": False,
                "velocidad_juego": 1.0
            }
        }
        self.archivo_config = "config.json"
        self.cargar_configuracion()

    def cargar_configuracion(self):
        try:
            with open(self.archivo_config, 'r') as f:
                config_cargada = json.load(f)
                self.actualizar_config_recursivo(self.config, config_cargada)
            print("✅ Configuración cargada correctamente")
        except FileNotFoundError:
            print("ℹ️  Archivo de configuración no encontrado, usando valores por defecto")
            self.guardar_configuracion()
        except Exception as e:
            print(f"❌ Error cargando configuración: {e}")

    def guardar_configuracion(self):
        try:
            with open(self.archivo_config, 'w') as f:
                json.dump(self.config, f, indent=4)
            print("✅ Configuración guardada correctamente")
        except Exception as e:
            print(f"❌ Error guardando configuración: {e}")

    def actualizar_config_recursivo(self, destino, origen):
        for clave, valor in origen.items():
            if clave in destino:
                if isinstance(valor, dict) and isinstance(destino[clave], dict):
                    self.actualizar_config_recursivo(destino[clave], valor)
                else:
                    destino[clave] = valor

    def aplicar_configuracion_audio(self, sistema_sonido):
        if sistema_sonido:
            sistema_sonido.volumen_efectos = self.config["audio"]["volumen_efectos"]
            sistema_sonido.volumen_musica = self.config["audio"]["volumen_musica"]
            sistema_sonido.sonidos_activados = self.config["audio"]["sonidos_activados"]

            for sonido in sistema_sonido.sonidos.values():
                sonido.set_volume(sistema_sonido.volumen_efectos)

    def obtener_tecla(self, jugador, accion):
        return self.config["controles"][f"jugador{jugador}"][accion]


# =============================================================================
# SISTEMA DE SONIDO
# =============================================================================

class SistemaSonido:
    def __init__(self):
        self.sonidos = {}
        self.musica_fondo = None
        self.volumen_efectos = 0.7
        self.volumen_musica = 0.5
        self.sonidos_activados = True

    def cargar_sonidos(self):
        try:
            self.sonidos = {
                'golpe_suave': self._crear_sonido_placeholder(200, 0.3),
                'golpe_fuerte': self._crear_sonido_placeholder(150, 0.6),
                'salto': self._crear_sonido_placeholder(300, 0.2),
                'habilidad': self._crear_sonido_placeholder(400, 0.4),
                'menu_select': self._crear_sonido_placeholder(500, 0.3),
                'victoria': self._crear_sonido_placeholder(600, 0.5),
                'impacto_epico': self._crear_sonido_placeholder(100, 0.8),
                'powerup': self._crear_sonido_placeholder(800, 0.3),
                'error': self._crear_sonido_placeholder(100, 0.2)
            }

            for sonido in self.sonidos.values():
                sonido.set_volume(self.volumen_efectos)

            print("✅ Sistema de sonido cargado correctamente")

        except Exception as e:
            print(f"❌ Error cargando sonidos: {e}")
            self.crear_sonidos_placeholder_simple()

    def _crear_sonido_placeholder(self, frecuencia, duracion):
        try:
            sample_count = int(duracion * 22050)
            sound_data = []

            for i in range(sample_count):
                t = i / 22050.0
                sample = 0.5 if (t * frecuencia % 1) > 0.5 else -0.5
                sound_data.append(sample)

            import array
            sound_array = array.array('h', [int(x * 32767) for x in sound_data])
            sound_bytes = sound_array.tobytes()

            return pygame.mixer.Sound(buffer=sound_bytes)

        except:
            return pygame.mixer.Sound(buffer=bytes())

    def crear_sonidos_placeholder_simple(self):
        self.sonidos = {
            'golpe_suave': pygame.mixer.Sound(buffer=bytes()),
            'golpe_fuerte': pygame.mixer.Sound(buffer=bytes()),
            'salto': pygame.mixer.Sound(buffer=bytes()),
            'habilidad': pygame.mixer.Sound(buffer=bytes()),
            'menu_select': pygame.mixer.Sound(buffer=bytes()),
            'victoria': pygame.mixer.Sound(buffer=bytes()),
            'impacto_epico': pygame.mixer.Sound(buffer=bytes()),
            'powerup': pygame.mixer.Sound(buffer=bytes()),
            'error': pygame.mixer.Sound(buffer=bytes())
        }

    def reproducir_sonido(self, nombre):
        if self.sonidos_activados and nombre in self.sonidos:
            self.sonidos[nombre].play()

    def reproducir_musica(self, loop=True):
        if self.sonidos_activados:
            try:
                pass
            except:
                print("Música no disponible en modo placeholder")

    def alternar_sonido(self):
        self.sonidos_activados = not self.sonidos_activados
        return self.sonidos_activados

    def ajustar_volumen_efectos(self, nuevo_volumen):
        self.volumen_efectos = max(0.0, min(1.0, nuevo_volumen))
        for sonido in self.sonidos.values():
            sonido.set_volume(self.volumen_efectos)


# =============================================================================
# SISTEMA DE PARTÍCULAS MEJORADO
# =============================================================================

class SistemaParticulas:
    def __init__(self):
        self.particulas = collections.deque()  # Usar deque para mejor rendimiento
        self.max_particulas = 500

    def agregar_particulas(self, x, y, color, cantidad=5, velocidad=2, tipo="normal", duracion=None):
        if duracion is None:
            duracion = random.randint(20, 40)

        # Limpiar partículas antiguas si hay demasiadas
        self.limpiar_exceso()

        for _ in range(cantidad):
            vel_x = 0
            vel_y = 0

            if tipo == "normal":
                angulo = random.uniform(0, 2 * math.pi)
                vel_x = math.cos(angulo) * velocidad * random.uniform(0.5, 1.5)
                vel_y = math.sin(angulo) * velocidad * random.uniform(0.5, 1.5)
            elif tipo == "explosion":
                angulo = random.uniform(0, 2 * math.pi)
                fuerza = random.uniform(0.5, 1.5)
                vel_x = math.cos(angulo) * velocidad * fuerza
                vel_y = math.sin(angulo) * velocidad * fuerza
            elif tipo == "chorro":
                direccion = 1 if random.random() > 0.5 else -1
                angulo = random.uniform(-0.5, 0.5)
                vel_x = math.cos(angulo) * velocidad * direccion * random.uniform(0.8, 1.2)
                vel_y = math.sin(angulo) * velocidad * random.uniform(0.8, 1.2)
            elif tipo == "flotante":
                angulo = random.uniform(0, 2 * math.pi)
                vel_x = math.cos(angulo) * velocidad * 0.3 * random.uniform(0.5, 1.0)
                vel_y = math.sin(angulo) * velocidad * 0.3 * random.uniform(0.5, 1.0) - 0.5
            elif tipo == "gravedad":
                angulo = random.uniform(0, 2 * math.pi)
                vel_x = math.cos(angulo) * velocidad * random.uniform(0.5, 1.5)
                vel_y = math.sin(angulo) * velocidad * random.uniform(0.5, 1.5)
            else:
                angulo = random.uniform(0, 2 * math.pi)
                vel_x = math.cos(angulo) * velocidad * random.uniform(0.5, 1.5)
                vel_y = math.sin(angulo) * velocidad * random.uniform(0.5, 1.5)

            tamaño = random.randint(2, 6)
            vida = duracion
            variacion_color = tuple(max(0, min(255, c + random.randint(-20, 20))) for c in color)

            self.particulas.append({
                'x': x, 'y': y,
                'vel_x': vel_x, 'vel_y': vel_y,
                'vida': vida, 'vida_max': vida,
                'color': variacion_color,
                'tamaño': tamaño,
                'tipo': tipo,
                'rotacion': random.uniform(0, 360)
            })

    def limpiar_exceso(self):
        """Elimina partículas antiguas si hay demasiadas"""
        while len(self.particulas) > self.max_particulas:
            self.particulas.popleft()

    def actualizar(self):
        # Usar índice en lugar de iterar sobre copia
        i = 0
        while i < len(self.particulas):
            particula = self.particulas[i]

            if particula['tipo'] == "normal":
                particula['vel_y'] += 0.1
            elif particula['tipo'] == "explosion":
                particula['vel_x'] *= 0.95
                particula['vel_y'] *= 0.95
            elif particula['tipo'] == "flotante":
                particula['vel_y'] -= 0.02
                particula['vel_x'] *= 0.98
            elif particula['tipo'] == "gravedad":
                particula['vel_y'] += 0.2

            particula['x'] += particula['vel_x']
            particula['y'] += particula['vel_y']
            particula['vida'] -= 1

            if particula['vida'] <= 0:
                # Eliminar eficientemente
                del self.particulas[i]
                continue

            i += 1

    def dibujar(self, ventana):
        for particula in self.particulas:
            alpha = int(255 * (particula['vida'] / particula['vida_max']))
            color = particula['color']

            surf = pygame.Surface((particula['tamaño'] * 2, particula['tamaño'] * 2), pygame.SRCALPHA)

            if particula['tipo'] == "explosion":
                pygame.draw.circle(surf, (*color, alpha),
                                   (particula['tamaño'], particula['tamaño']),
                                   particula['tamaño'])
                pygame.draw.circle(surf, (255, 255, 200, alpha // 2),
                                   (particula['tamaño'], particula['tamaño']),
                                   particula['tamaño'] + 2)
            elif particula['tipo'] == "flotante":
                puntos = []
                for i in range(5):
                    angulo = particula['rotacion'] + i * 72
                    radio_externo = particula['tamaño']
                    radio_interno = particula['tamaño'] // 2
                    x_ext = particula['tamaño'] + math.cos(math.radians(angulo)) * radio_externo
                    y_ext = particula['tamaño'] + math.sin(math.radians(angulo)) * radio_externo
                    x_int = particula['tamaño'] + math.cos(math.radians(angulo + 36)) * radio_interno
                    y_int = particula['tamaño'] + math.sin(math.radians(angulo + 36)) * radio_interno
                    puntos.extend([(x_ext, y_ext), (x_int, y_int)])
                pygame.draw.polygon(surf, (*color, alpha), puntos)
            else:
                pygame.draw.circle(surf, (*color, alpha),
                                   (particula['tamaño'], particula['tamaño']),
                                   particula['tamaño'])

            ventana.blit(surf, (int(particula['x'] - particula['tamaño']),
                                int(particula['y'] - particula['tamaño'])))


# =============================================================================
# SISTEMA DE TUTORIAL
# =============================================================================

class SistemaTutorial:
    def __init__(self):
        self.mensajes = {
            "movimiento": "←→ para moverse, ↑ para saltar",
            "ataque": "ESPACIO: rápido, SHIFT: pesado, F: aéreo",
            "bloqueo": "X para bloquear (reduce daño)",
            "habilidad": "Q para habilidad especial",
            "objetivo": "¡Golpea al oponente para ganar!"
        }
        self.mensaje_actual = None
        self.tiempo_mensaje = 0
        self.mensajes_mostrados = set()

    def mostrar_mensaje(self, tipo, duracion=4000):
        if tipo in self.mensajes and tipo not in self.mensajes_mostrados:
            self.mensaje_actual = self.mensajes[tipo]
            self.tiempo_mensaje = pygame.time.get_ticks() + duracion
            self.mensajes_mostrados.add(tipo)

    def actualizar(self):
        if self.mensaje_actual and pygame.time.get_ticks() > self.tiempo_mensaje:
            self.mensaje_actual = None

    def dibujar(self, ventana):
        if self.mensaje_actual:
            ancho, alto = ventana.get_size()
            fuente = pygame.font.SysFont('Arial', 24)
            texto = fuente.render(self.mensaje_actual, True, (255, 255, 0))
            s = pygame.Surface((ancho, texto.get_height() + 20))
            s.set_alpha(128)
            s.fill((0, 0, 0))
            ventana.blit(s, (0, alto - texto.get_height() - 20))
            ventana.blit(texto, (ancho // 2 - texto.get_width() // 2, alto - texto.get_height() - 10))


# =============================================================================
# SISTEMA DE COMBOS VISUAL
# =============================================================================

class SistemaCombosVisual:
    def __init__(self):
        self.combos_activos = []

    def agregar_combo(self, jugador, cantidad_golpes, daño_total):
        self.combos_activos.append({
            "jugador": jugador,
            "golpes": cantidad_golpes,
            "daño": daño_total,
            "tiempo": pygame.time.get_ticks(),
            "posicion": (jugador.x, jugador.y - 100),
            "escala": 1.0
        })

    def dibujar(self, ventana):
        tiempo_actual = pygame.time.get_ticks()
        for combo in self.combos_activos[:]:
            progreso = (tiempo_actual - combo["tiempo"]) / 2000
            if progreso > 1:
                self.combos_activos.remove(combo)
                continue

            alpha = int(255 * (1 - progreso))
            tamaño = 24 + int(16 * math.sin(progreso * math.pi))

            fuente = pygame.font.SysFont('Arial', tamaño, bold=True)
            texto = fuente.render(f"COMBO x{combo['golpes']}!", True, (255, 255, 0))
            texto.set_alpha(alpha)

            x, y = combo["posicion"]
            y -= int(50 * progreso)

            ventana.blit(texto, (x - texto.get_width() // 2, y))


# =============================================================================
# ADMINISTRADOR DE RECURSOS
# =============================================================================

class AdministradorRecursos:
    _instancia = None

    def __new__(cls):
        if cls._instancia is None:
            cls._instancia = super().__new__(cls)
            cls._instancia.cache_imagenes = {}
            cls._instancia.cache_sonidos = {}
        return cls._instancia

    def cargar_imagen(self, ruta, tamaño=None):
        clave = f"{ruta}_{tamaño}"
        if clave not in self.cache_imagenes:
            try:
                img = pygame.image.load(ruta)
                if tamaño:
                    img = pygame.transform.scale(img, tamaño)
                self.cache_imagenes[clave] = img.convert_alpha()
            except:
                surf = pygame.Surface(tamaño if tamaño else (100, 100), pygame.SRCALPHA)
                color = (random.randint(50, 200), random.randint(50, 200), random.randint(50, 200))
                pygame.draw.rect(surf, color, (10, 10, surf.get_width() - 20, surf.get_height() - 20), border_radius=15)
                pygame.draw.rect(surf, (255, 255, 255), (10, 10, surf.get_width() - 20, surf.get_height() - 20), 2,
                                 border_radius=15)
                self.cache_imagenes[clave] = surf
        return self.cache_imagenes[clave]


# =============================================================================
# SISTEMAS DE GAMEPLAY MEJORADOS
# =============================================================================

class SistemaFeedbackSatisfaccion:
    def __init__(self, camara):
        self.camara = camara
        self.impactos_recientes = []
        self.efectos_pantalla = []
        self.textos_flotantes = []

    def agregar_impacto_epico(self, x, y, poder, tipo="golpe"):
        if poder > 25:
            nivel = "epico"
            self.camara.activar_temblor(8, 400)
            self.activar_slow_moment(0.3, 300)
            self.activar_destello_pantalla((255, 255, 200), 200)
            self.mostrar_texto_flotante(x, y, "¡EPICO!", (255, 215, 0), 32)
        elif poder > 18:
            nivel = "fuerte"
            self.camara.activar_temblor(5, 250)
            self.activar_destello_pantalla((255, 200, 100), 150)
            self.mostrar_texto_flotante(x, y, "¡FUERTE!", (255, 100, 100), 28)
        elif poder > 12:
            nivel = "medio"
            self.camara.activar_temblor(3, 150)
            self.mostrar_texto_flotante(x, y, "¡BUENO!", (100, 255, 100), 24)
        else:
            nivel = "debil"
            self.mostrar_texto_flotante(x, y, "¡GOLPE!", (200, 200, 200), 20)

        self.reproducir_sonido_impacto(nivel, tipo)
        return nivel

    def activar_slow_moment(self, factor, duracion):
        self.efectos_pantalla.append({
            "tipo": "slow_motion",
            "factor": factor,
            "duracion": duracion,
            "inicio": pygame.time.get_ticks()
        })

    def activar_destello_pantalla(self, color, duracion):
        self.efectos_pantalla.append({
            "tipo": "destello",
            "color": color,
            "duracion": duracion,
            "inicio": pygame.time.get_ticks(),
            "alpha": 255
        })

    def mostrar_texto_flotante(self, x, y, texto, color, tamaño):
        self.textos_flotantes.append({
            "texto": texto,
            "x": x,
            "y": y,
            "color": color,
            "tamaño": tamaño,
            "velocidad": -2,
            "vida": 60,
            "alpha": 255
        })

    def reproducir_sonido_impacto(self, nivel, tipo):
        try:
            volumen = {
                "epico": 1.0,
                "fuerte": 0.8,
                "medio": 0.6,
                "debil": 0.4
            }.get(nivel, 0.5)
        except:
            pass

    def actualizar(self):
        tiempo_actual = pygame.time.get_ticks()
        for efecto in self.efectos_pantalla[:]:
            if tiempo_actual - efecto["inicio"] > efecto["duracion"]:
                self.efectos_pantalla.remove(efecto)
            elif efecto["tipo"] == "destello":
                progreso = (tiempo_actual - efecto["inicio"]) / efecto["duracion"]
                efecto["alpha"] = int(255 * (1 - progreso))

        for texto in self.textos_flotantes[:]:
            texto["y"] += texto["velocidad"]
            texto["vida"] -= 1
            texto["alpha"] = int(255 * (texto["vida"] / 60))
            if texto["vida"] <= 0:
                self.textos_flotantes.remove(texto)

    def dibujar(self, ventana):
        for efecto in self.efectos_pantalla:
            if efecto["tipo"] == "destello":
                overlay = pygame.Surface((ANCHO, ALTO))
                overlay.fill(efecto["color"])
                overlay.set_alpha(efecto["alpha"])
                ventana.blit(overlay, (0, 0))

        for texto in self.textos_flotantes:
            fuente = pygame.font.SysFont('Arial', texto["tamaño"], bold=True)
            surf_texto = fuente.render(texto["texto"], True, texto["color"])
            surf_texto.set_alpha(texto["alpha"])
            rect_texto = surf_texto.get_rect(center=(texto["x"], texto["y"]))
            ventana.blit(surf_texto, rect_texto)


class SistemaMomentum:
    def __init__(self):
        self.momentum_j1 = 50
        self.momentum_j2 = 50
        self.ventaja_acumulada = 0

    def actualizar_momentum(self, jugador1, jugador2):
        ventaja_actual = jugador2.porcentaje_dano - jugador1.porcentaje_dano

        if ventaja_actual > 30:
            self.momentum_j1 = min(100, self.momentum_j1 + 3)
            self.momentum_j2 = max(0, self.momentum_j2 - 3)
        elif ventaja_actual > 15:
            self.momentum_j1 = min(100, self.momentum_j1 + 1)
            self.momentum_j2 = max(0, self.momentum_j2 - 1)
        elif ventaja_actual < -30:
            self.momentum_j1 = max(0, self.momentum_j1 - 3)
            self.momentum_j2 = min(100, self.momentum_j2 + 3)
        elif ventaja_actual < -15:
            self.momentum_j1 = max(0, self.momentum_j1 - 1)
            self.momentum_j2 = min(100, self.momentum_j2 + 1)
        else:
            self.momentum_j1 += (50 - self.momentum_j1) * 0.05
            self.momentum_j2 += (50 - self.momentum_j2) * 0.05

        self.aplicar_bonificaciones_momentum(jugador1, jugador2)
        return self.momentum_j1, self.momentum_j2

    def aplicar_bonificaciones_momentum(self, jugador1, jugador2):
        if self.momentum_j1 > 70:
            jugador1.velocidad_boost = 1.0 + (self.momentum_j1 - 70) / 100
            jugador1.dano_boost = 1.0 + (self.momentum_j1 - 70) / 200
        else:
            jugador1.velocidad_boost = 1.0
            jugador1.dano_boost = 1.0

        if self.momentum_j2 > 70:
            jugador2.velocidad_boost = 1.0 + (self.momentum_j2 - 70) / 100
            jugador2.dano_boost = 1.0 + (self.momentum_j2 - 70) / 200
        else:
            jugador2.velocidad_boost = 1.0
            jugador2.dano_boost = 1.0


class MecanicasClutch:
    def __init__(self):
        self.habilidades_clutch = {}
        self.contadores_near_death = {}
        self.anuncios_clutch = []

    def verificar_situacion_clutch(self, jugador, stocks_restantes, porcentaje_dano):
        es_clutch = (stocks_restantes == 1 and porcentaje_dano > 80)
        es_near_death = (porcentaje_dano > 120)

        if es_clutch and jugador not in self.habilidades_clutch:
            self.activar_habilidad_clutch(jugador)
            return True

        if es_near_death:
            if jugador not in self.contadores_near_death:
                self.contadores_near_death[jugador] = 0
            self.contadores_near_death[jugador] += 1
            if self.contadores_near_death[jugador] % 180 == 0:
                self.activar_efecto_supervivencia(jugador)
        return False

    def activar_habilidad_clutch(self, jugador):
        habilidades = [
            {"nombre": "ESCUDO EMERGENCIA", "tipo": "defensa", "duracion": 8000},
            {"nombre": "ATAQUE DESESPERADO", "tipo": "ataque", "duracion": 10000},
            {"nombre": "VELOCIDAD DESESPERADA", "tipo": "movimiento", "duracion": 12000},
            {"nombre": "RECUPERACIÓN RÁPIDA", "tipo": "utilidad", "duracion": 15000}
        ]

        habilidad = random.choice(habilidades)
        self.habilidades_clutch[jugador] = {
            **habilidad,
            "inicio": pygame.time.get_ticks()
        }

        if habilidad["tipo"] == "defensa":
            jugador.invencible = True
            jugador.tiempo_invencibilidad = pygame.time.get_ticks() + 2000
        elif habilidad["tipo"] == "ataque":
            jugador.dano_boost_clutch = 1.5
        elif habilidad["tipo"] == "movimiento":
            jugador.velocidad_boost_clutch = 1.4
        elif habilidad["tipo"] == "utilidad":
            jugador.regeneracion_clutch = True

        self.mostrar_anuncio_clutch(jugador, habilidad["nombre"])

    def activar_efecto_supervivencia(self, jugador):
        jugador.curar(5)
        self.mostrar_anuncio_clutch(jugador, "¡SUPERVIVENCIA!")

    def mostrar_anuncio_clutch(self, jugador, mensaje):
        self.anuncios_clutch.append({
            "jugador": jugador.controles,
            "mensaje": mensaje,
            "tiempo": pygame.time.get_ticks(),
            "duracion": 3000,
            "y": 200 if jugador.controles == "jugador1" else 250
        })

    def actualizar(self, jugador1, jugador2):
        tiempo_actual = pygame.time.get_ticks()
        for jugador, habilidad in list(self.habilidades_clutch.items()):
            if tiempo_actual - habilidad["inicio"] > habilidad["duracion"]:
                self.remover_habilidad_clutch(jugador)

        for anuncio in self.anuncios_clutch[:]:
            if tiempo_actual - anuncio["tiempo"] > anuncio["duracion"]:
                self.anuncios_clutch.remove(anuncio)

    def remover_habilidad_clutch(self, jugador):
        if jugador in self.habilidades_clutch:
            habilidad = self.habilidades_clutch[jugador]["tipo"]
            if habilidad == "defensa":
                jugador.invencible = False
            elif habilidad == "ataque":
                jugador.dano_boost_clutch = 1.0
            elif habilidad == "movimiento":
                jugador.velocidad_boost_clutch = 1.0
            elif habilidad == "utilidad":
                jugador.regeneracion_clutch = False
            del self.habilidades_clutch[jugador]


class SistemaStun:
    def __init__(self):
        self.jugadores_stuneados = {}
        self.indicadores_qte = {}

    def aplicar_stun(self, jugador, duracion_base, poder_golpe):
        duracion = duracion_base + (poder_golpe * 15)
        self.jugadores_stuneados[jugador] = {
            "inicio": pygame.time.get_ticks(),
            "duracion": duracion,
            "tipo": "normal"
        }
        if duracion > 1000:
            self.activar_qte(jugador, duracion)
        jugador.esta_stuneado = True
        return duracion

    def activar_qte(self, jugador, duracion_total):
        teclas_qte = []
        if jugador.controles == "jugador1":
            teclas_qte = [pygame.K_LEFT, pygame.K_RIGHT, pygame.K_UP, pygame.K_DOWN]
        else:
            teclas_qte = [pygame.K_a, pygame.K_d, pygame.K_w, pygame.K_s]

        cantidad_teclas = random.randint(2, 3)
        teclas_seleccionadas = random.sample(teclas_qte, cantidad_teclas)
        self.indicadores_qte[jugador] = {
            "teclas": teclas_seleccionadas,
            "teclas_presionadas": [False] * cantidad_teclas,
            "inicio": pygame.time.get_ticks(),
            "duracion": 2000
        }

    def verificar_qte(self, jugador, teclas_func):
        if jugador not in self.indicadores_qte:
            return False
        qte = self.indicadores_qte[jugador]
        completado = True
        for i, tecla in enumerate(qte["teclas"]):
            if teclas_func(tecla):
                qte["teclas_presionadas"][i] = True
            if not qte["teclas_presionadas"][i]:
                completado = False
        if completado:
            self.romper_stun(jugador)
            return True
        if pygame.time.get_ticks() - qte["inicio"] > qte["duracion"]:
            del self.indicadores_qte[jugador]
        return False

    def romper_stun(self, jugador):
        if jugador in self.jugadores_stuneados:
            stun_data = self.jugadores_stuneados[jugador]
            tiempo_restante = stun_data["duracion"] - (pygame.time.get_ticks() - stun_data["inicio"])
            nuevo_fin = pygame.time.get_ticks() + (tiempo_restante // 4)
            self.jugadores_stuneados[jugador]["duracion"] = nuevo_fin - stun_data["inicio"]
            if jugador in self.indicadores_qte:
                del self.indicadores_qte[jugador]

    def actualizar(self, teclas_func):
        tiempo_actual = pygame.time.get_ticks()
        for jugador, stun_data in list(self.jugadores_stuneados.items()):
            self.verificar_qte(jugador, teclas_func)
            if tiempo_actual - stun_data["inicio"] > stun_data["duracion"]:
                jugador.esta_stuneado = False
                del self.jugadores_stuneados[jugador]
                if jugador in self.indicadores_qte:
                    del self.indicadores_qte[jugador]


class SistemaEstilo:
    def __init__(self):
        self.puntuacion_j1 = 0
        self.puntuacion_j2 = 0
        self.combo_actual_j1 = 0
        self.combo_actual_j2 = 0
        self.ultimas_acciones = {"j1": [], "j2": []}
        self.textos_estilo = []

    def registrar_accion(self, jugador_id, accion, contexto=None):
        puntos_base = {
            "golpe_normal": 10,
            "golpe_fuerte": 25,
            "golpe_aereo": 30,
            "contraataque": 40,
            "esquiva_perfecta": 20,
            "combo_3": 50,
            "combo_5": 100,
            "combo_10": 200,
            "kill_epico": 150,
            "supervivencia": 75,
            "romper_stun": 35
        }

        puntos = puntos_base.get(accion, 0)
        if contexto:
            if contexto.get("porcentaje_alto", False):
                puntos += 20
            if contexto.get("ultimo_stock", False):
                puntos += 30
            if contexto.get("contraataque", False):
                puntos *= 1.5

        multiplicador_variedad = self.calcular_multiplicador_variedad(jugador_id, accion)
        puntos = int(puntos * multiplicador_variedad)

        if jugador_id == "j1":
            self.puntuacion_j1 += puntos
            if "combo" in accion:
                self.combo_actual_j1 += 1
            else:
                self.combo_actual_j1 = 0
        else:
            self.puntuacion_j2 += puntos
            if "combo" in accion:
                self.combo_actual_j2 += 1
            else:
                self.combo_actual_j2 = 0

        self.mostrar_puntos_estilo(jugador_id, puntos, accion, contexto)
        return puntos

    def calcular_multiplicador_variedad(self, jugador_id, nueva_accion):
        historial = self.ultimas_acciones[jugador_id]
        if len(historial) > 0 and nueva_accion == historial[-1]:
            return 0.7
        acciones_unicas = len(set(historial))
        multiplicador = 1.0 + (acciones_unicas * 0.1)
        historial.append(nueva_accion)
        if len(historial) > 5:
            historial.pop(0)
        return min(multiplicador, 2.0)

    def mostrar_puntos_estilo(self, jugador_id, puntos, accion, contexto):
        if puntos <= 0:
            return
        x = ANCHO // 4 if jugador_id == "j1" else 3 * ANCHO // 4
        y = ALTO // 3
        if puntos >= 100:
            color = (255, 215, 0)
            tamaño = 28
            prefijo = "¡ÉPICO! "
        elif puntos >= 50:
            color = (255, 100, 255)
            tamaño = 24
            prefijo = "¡IMPRESIONANTE! "
        elif puntos >= 25:
            color = (100, 255, 255)
            tamaño = 20
            prefijo = "¡BUENO! "
        else:
            color = (200, 200, 200)
            tamaño = 18
            prefijo = ""
        texto = f"{prefijo}+{puntos}"
        self.textos_estilo.append({
            "texto": texto,
            "x": x,
            "y": y,
            "color": color,
            "tamaño": tamaño,
            "velocidad": -1.5,
            "vida": 90,
            "alpha": 255
        })

    def actualizar(self):
        for texto in self.textos_estilo[:]:
            texto["y"] += texto["velocidad"]
            texto["vida"] -= 1
            texto["alpha"] = int(255 * (texto["vida"] / 90))
            if texto["vida"] <= 0:
                self.textos_estilo.remove(texto)

    def dibujar(self, ventana):
        for texto in self.textos_estilo:
            fuente = pygame.font.SysFont('Arial', texto["tamaño"], bold=True)
            surf_texto = fuente.render(texto["texto"], True, texto["color"])
            surf_texto.set_alpha(texto["alpha"])
            rect_texto = surf_texto.get_rect(center=(texto["x"], texto["y"]))
            ventana.blit(surf_texto, rect_texto)


# =============================================================================
# CLASES BASE DEL JUEGO
# =============================================================================

class Camara:
    def __init__(self, ANCHO, ALTO):
        self.ANCHO = ANCHO
        self.ALTO = ALTO
        self.temblor = 0
        self.tiempo_temblor = 0
        self.zoom = 1.0
        self.objetivo_zoom = 1.0
        self.slow_motion = False
        self.factor_slow_motion = 1.0

    def activar_temblor(self, intensidad, duracion):
        self.temblor = intensidad
        self.tiempo_temblor = pygame.time.get_ticks() + duracion

    def activar_slow_motion(self, factor, duracion):
        self.slow_motion = True
        self.factor_slow_motion = factor
        self.tiempo_slow_motion = pygame.time.get_ticks() + duracion

    def actualizar(self):
        offset_x, offset_y = 0, 0
        if pygame.time.get_ticks() < self.tiempo_temblor:
            offset_x = random.randint(-self.temblor, self.temblor)
            offset_y = random.randint(-self.temblor, self.temblor)
        if hasattr(self, 'tiempo_slow_motion') and pygame.time.get_ticks() < self.tiempo_slow_motion:
            self.slow_motion = True
        else:
            self.slow_motion = False
            self.factor_slow_motion = 1.0
        return (offset_x, offset_y)

    def aplicar_a_superficie(self, superficie):
        if self.zoom != 1.0:
            nueva_ancho = int(self.ANCHO * self.zoom)
            nueva_alto = int(self.ALTO * self.zoom)
            zoomed = pygame.transform.scale(superficie, (nueva_ancho, nueva_alto))
            x = (self.ANCHO - nueva_ancho) // 2
            y = (self.ALTO - nueva_alto) // 2
            superficie.fill((0, 0, 0))
            superficie.blit(zoomed, (x, y))


class HabilidadEspecial:
    def __init__(self, jugador, tipo):
        self.jugador = jugador
        self.tipo = tipo
        self.carga_maxima = 100
        self.carga_actual = 0
        self.activada = False
        self.tiempo_activacion = 0
        self.duracion = 0
        self.dano_extra = 0
        self.velocidad_extra = 0
        self.reduccion_dano = 0

        if tipo == "golpe_cargado":
            self.duracion = 3000
            self.dano_extra = 30
        elif tipo == "dash_ataque":
            self.duracion = 2000
            self.velocidad_extra = 15
        elif tipo == "bloqueo_fuerte":
            self.duracion = 4000
            self.reduccion_dano = 0.9
        elif tipo == "rayo_energia":
            self.duracion = 1500
            self.dano_extra = 40

    def cargar(self, cantidad):
        self.carga_actual = min(self.carga_actual + cantidad, self.carga_maxima)

    def activar(self):
        if self.carga_actual >= self.carga_maxima and not self.activada:
            self.activada = True
            self.tiempo_activacion = pygame.time.get_ticks()
            self.carga_actual = 0
            return True
        return False

    def actualizar(self):
        if self.activada and pygame.time.get_ticks() - self.tiempo_activacion > self.duracion:
            self.activada = False

    def esta_activa(self):
        return self.activada


class Jugador:
    def __init__(self, x, y, frames_idle, frames_run, frames_attack, frames_hit, tamano, controles, clase_personaje,
                 sistema_progresion, modo_combos_infinitos=False):
        self.x = x
        self.y = y
        self.frames_idle = frames_idle
        self.frames_run = frames_run
        self.frames_attack = frames_attack
        self.frames_hit = frames_hit
        self.tamano = tamano
        self.controles = controles
        self.clase = clase_personaje
        self.config_clase = CLASES_PERSONAJE[clase_personaje]
        self.sistema_progresion = sistema_progresion
        self.modo_combos_infinitos = modo_combos_infinitos  # Nuevo: modo combos infinitos

        # Obtener nivel del sistema de progresión
        stats_personaje = self.sistema_progresion.obtener_estadisticas_personaje(clase_personaje)
        self.nivel = stats_personaje["nivel"] if stats_personaje else 1

        # Calcular estadísticas basadas en nivel
        self.vida_base = self.config_clase["vida"] + (self.nivel - 1) * self.config_clase["bonus_nivel"]["vida"]
        self.dano_base = self.config_clase["dano_base"] + (self.nivel - 1) * self.config_clase["bonus_nivel"]["dano"]
        self.velocidad_base = self.config_clase["velocidad"] + (self.nivel - 1) * self.config_clase["bonus_nivel"][
            "velocidad"]

        # Sistema de habilidades
        self.habilidades_activas = {
            "dash_mejorado": False,
            "defensa_mejorada": False,
            "contraataque": False,
            "carga_rapida": False,
            "super_armor": False,
            "regeneracion": False,
            "dano_critico": False,
            "velocidad_maxima": False,
            "habilidad_maestra": False
        }
        self.activar_habilidades_desbloqueadas()

        # Estado del jugador
        self.velocidad = self.velocidad_base
        self.mirando_derecha = controles == "jugador1"
        self.esta_corriendo = False
        self.esta_atacando = False
        self.esta_recibiendo_dano = False
        self.esta_bloqueando = False
        self.esta_haciendo_dash = False

        # Sistema de salto
        self.velocidad_y = 0
        self.esta_saltando = False
        self.gravedad = 1.2
        self.fuerza_salto = -22
        self.velocidad_caida_maxima = 18
        self.control_aereo = 0.6

        # Sistema de porcentaje de daño
        self.porcentaje_dano = 0
        self.vida_maxima = self.vida_base
        self.vida_actual = self.vida_maxima

        # Atributos para mecánicas mejoradas
        self.esta_stuneado = False
        self.velocidad_boost = 1.0
        self.dano_boost = 1.0
        self.velocidad_boost_clutch = 1.0
        self.dano_boost_clutch = 1.0
        self.regeneracion_clutch = False
        self.invencible = False
        self.tiempo_invencibilidad = 0

        # Sistema de combos - MODIFICADO PARA COMBOS INFINITOS
        self.combo_count = 0
        self.combo_timer = 0
        self.combo_max_time = 60  # Aumentado para combos más largos

        # En modo combos infinitos, el daño aumenta indefinidamente
        if self.modo_combos_infinitos:
            self.dano_combo = [self.dano_base]
            # El daño aumenta 0.5 por cada golpe en combo
            self.incremento_dano_combo = 0.5
        else:
            self.dano_combo = [self.dano_base, self.dano_base + 3, self.dano_base + 6]

        # Sistema de ataques
        self.ataque_actual = None
        self.tiempo_ultimo_ataque = 0

        # Animaciones
        self.indice_idle = 0
        self.indice_run = 0
        self.indice_attack = 0
        self.indice_hit = 0
        self.contador_idle = 0
        self.contador_run = 0
        self.contador_attack = 0
        self.contador_hit = 0
        self.velocidad_idle = 8
        self.velocidad_run = 4
        self.velocidad_attack = 3
        self.velocidad_hit = 5

        self.sprite_actual = self.frames_idle[0]

        # Hitbox de ataque
        self.hitbox_ataque_activa = False
        self.tiempo_hitbox = 0

        # Habilidad especial
        self.habilidad_especial = HabilidadEspecial(self, self.config_clase["habilidad"])

        # Efectos activos
        self.efectos_activos = {}

        # Estadísticas
        self.estadisticas = {
            "golpes_conectados": 0,
            "golpes_recibidos": 0,
            "max_combo": 0,
            "powerups_recogidos": 0,
            "habilidades_usadas": 0,
            "puntos_estilo": 0
        }

    def activar_habilidades_desbloqueadas(self):
        """Activa las habilidades desbloqueadas según el nivel del personaje"""
        habilidades_desbloqueadas = self.sistema_progresion.obtener_habilidades_desbloqueadas(self.clase)
        for habilidad in habilidades_desbloqueadas:
            if habilidad in self.habilidades_activas:
                self.habilidades_activas[habilidad] = True

    def recibir_dano(self, cantidad, sistema_sonido=None, sistema_particulas=None, posicion_impacto=None):
        if self.invencible:
            return False

        if self.esta_bloqueando:
            cantidad = cantidad * 0.3

        if not self.esta_recibiendo_dano:
            self.porcentaje_dano += cantidad
            self.vida_actual = max(0, self.vida_actual - cantidad)

            self.esta_recibiendo_dano = True
            self.indice_hit = 0
            self.contador_hit = 0
            self.estadisticas["golpes_recibidos"] += 1

            retroceso_base = 15
            retroceso_extra = (self.porcentaje_dano / 100) * 20
            retroceso_total = retroceso_base + retroceso_extra

            if self.mirando_derecha:
                self.x -= retroceso_total
            else:
                self.x += retroceso_total

            if sistema_particulas and posicion_impacto:
                sistema_particulas.agregar_particulas(
                    posicion_impacto[0], posicion_impacto[1],
                    (255, 50, 50), 12, 4, "explosion"
                )

            if sistema_sonido:
                sistema_sonido.reproducir_sonido('golpe_fuerte')

            return True
        return False

    def curar(self, cantidad):
        self.vida_actual = min(self.vida_actual + cantidad, self.vida_maxima)
        self.porcentaje_dano = max(0, self.porcentaje_dano - (cantidad / 2))

    def get_dano_ataque(self):
        """Calcula el daño del ataque actual, incluyendo bonus de combo"""
        if self.modo_combos_infinitos:
            # En modo combos infinitos, el daño base aumenta con el combo
            dano_base = self.dano_base + (self.combo_count * self.incremento_dano_combo)
        else:
            # Modo normal: daño limitado a 3 niveles
            dano_base = self.dano_combo[min(self.combo_count, len(self.dano_combo) - 1)]

        if self.ataque_actual == "pesado":
            dano_base *= 1.8  # Aumentado de 1.5 para que los ataques pesados sean más efectivos
        elif self.ataque_actual == "aereo":
            dano_base *= 1.4  # Aumentado de 1.3

        if self.habilidad_especial.esta_activa() and self.habilidad_especial.tipo == "golpe_cargado":
            dano_base += self.habilidad_especial.dano_extra

        dano_base *= self.dano_boost
        dano_base *= self.dano_boost_clutch

        return int(dano_base)

    def actualizar(self, teclas, ANCHO, ALTO, plataformas, limite_izq=0, limite_der=None):
        if limite_der is None:
            limite_der = ANCHO

        if self.esta_stuneado:
            if self.esta_recibiendo_dano:
                self.contador_hit += 1
                if self.contador_hit >= self.velocidad_hit:
                    self.contador_hit = 0
                    self.indice_hit += 1
                    if self.indice_hit >= len(self.frames_hit):
                        self.indice_hit = 0
                        self.esta_recibiendo_dano = False
                self.sprite_actual = self.frames_hit[self.indice_hit]
            return

        self.actualizar_efectos()
        self.habilidad_especial.actualizar()
        self.actualizar_combo()

        velocidad_efectiva = self.velocidad_base * self.velocidad_boost * self.velocidad_boost_clutch

        self.esta_corriendo = False

        self.velocidad_y += self.gravedad
        if self.velocidad_y > self.velocidad_caida_maxima:
            self.velocidad_y = self.velocidad_caida_maxima

        self.y += self.velocidad_y

        en_suelo = False
        rect_jugador = self.get_rect()

        for plataforma in plataformas:
            if rect_jugador.colliderect(plataforma.rect):
                if self.velocidad_y > 0 and self.y + self.tamano[1] <= plataforma.rect.top + 10:
                    self.y = plataforma.rect.top - self.tamano[1]
                    self.velocidad_y = 0
                    self.esta_saltando = False
                    en_suelo = True
                elif self.velocidad_y < 0 and self.y >= plataforma.rect.bottom - 10:
                    self.y = plataforma.rect.bottom
                    self.velocidad_y = 0
                elif self.velocidad_y == 0:
                    if self.x + self.tamano[0] > plataforma.rect.left and self.x < plataforma.rect.left:
                        self.x = plataforma.rect.left - self.tamano[0]
                    elif self.x < plataforma.rect.right and self.x + self.tamano[0] > plataforma.rect.right:
                        self.x = plataforma.rect.right

        if self.y >= ALTO - self.tamano[1] and not en_suelo:
            self.y = ALTO - self.tamano[1]
            self.velocidad_y = 0
            self.esta_saltando = False
            self.velocidad = velocidad_efectiva
        elif not en_suelo:
            self.velocidad = velocidad_efectiva * self.control_aereo
        else:
            self.velocidad = velocidad_efectiva

        if self.regeneracion_clutch and pygame.time.get_ticks() % 60 == 0:
            self.curar(1)

        if self.esta_haciendo_dash and pygame.time.get_ticks() - getattr(self, 'tiempo_dash', 0) > 200:
            self.esta_haciendo_dash = False
            self.velocidad = velocidad_efectiva

        if self.esta_recibiendo_dano:
            self.contador_hit += 1
            if self.contador_hit >= self.velocidad_hit:
                self.contador_hit = 0
                self.indice_hit += 1
                if self.indice_hit >= len(self.frames_hit):
                    self.indice_hit = 0
                    self.esta_recibiendo_dano = False
            self.sprite_actual = self.frames_hit[self.indice_hit]

        elif self.esta_atacando:
            self.contador_attack += 1
            if self.contador_attack >= self.velocidad_attack:
                self.contador_attack = 0
                self.indice_attack += 1

                if not self.hitbox_ataque_activa:
                    # ACTIVAR HITBOX EN EL FRAME CORRECTO
                    if self.ataque_actual == "rapido" and self.indice_attack == 2:
                        self.hitbox_ataque_activa = True
                        self.tiempo_hitbox = pygame.time.get_ticks()
                    elif self.ataque_actual == "pesado" and self.indice_attack == 2:  # Cambiado de 3 a 2 para activar más rápido
                        self.hitbox_ataque_activa = True
                        self.tiempo_hitbox = pygame.time.get_ticks()
                    elif self.ataque_actual == "aereo" and self.indice_attack == 1:  # Activado más temprano
                        self.hitbox_ataque_activa = True
                        self.tiempo_hitbox = pygame.time.get_ticks()

                if self.indice_attack >= len(self.frames_attack):
                    self.indice_attack = 0
                    self.esta_atacando = False
                    self.hitbox_ataque_activa = False
                    self.ataque_actual = None
            self.sprite_actual = self.frames_attack[self.indice_attack]

        elif not self.esta_atacando and not self.esta_recibiendo_dano:
            movimiento_x = 0

            if self.controles == "jugador1":
                if teclas(pygame.K_LEFT):
                    movimiento_x -= self.velocidad
                    self.mirando_derecha = False
                    self.esta_corriendo = True
                if teclas(pygame.K_RIGHT):
                    movimiento_x += self.velocidad
                    self.mirando_derecha = True
                    self.esta_corriendo = True

            elif self.controles == "jugador2":
                if teclas(pygame.K_a):
                    movimiento_x -= self.velocidad
                    self.mirando_derecha = False
                    self.esta_corriendo = True
                if teclas(pygame.K_d):
                    movimiento_x += self.velocidad
                    self.mirando_derecha = True
                    self.esta_corriendo = True

            self.x += movimiento_x
            self.x = max(limite_izq, min(self.x, limite_der - self.tamano[0]))

            if self.esta_corriendo:
                self.contador_run += 1
                if self.contador_run >= self.velocidad_run:
                    self.contador_run = 0
                    self.indice_run = (self.indice_run + 1) % len(self.frames_run)
                self.sprite_actual = self.frames_run[self.indice_run]
            elif not self.esta_saltando:
                self.contador_idle += 1
                if self.contador_idle >= self.velocidad_idle:
                    self.contador_idle = 0
                    self.indice_idle = (self.indice_idle + 1) % len(self.frames_idle)
                self.sprite_actual = self.frames_idle[self.indice_idle]

        # La hitbox se desactiva después de un tiempo
        if self.hitbox_ataque_activa and pygame.time.get_ticks() - self.tiempo_hitbox > 200:  # Aumentado de 150 a 200
            self.hitbox_ataque_activa = False

    def get_hitbox_ataque(self):
        if self.hitbox_ataque_activa:
            if self.ataque_actual == "rapido":
                ancho_hitbox = 60
                alto_hitbox = 50
                offset_y = 80
            elif self.ataque_actual == "pesado":
                ancho_hitbox = 120  # Aumentado de 100 para mejor hit detection
                alto_hitbox = 80  # Aumentado de 70
                offset_y = 70
            elif self.ataque_actual == "aereo":
                ancho_hitbox = 80
                alto_hitbox = 80
                offset_y = 40
            else:
                ancho_hitbox = 80
                alto_hitbox = 60
                offset_y = 80

            if self.mirando_derecha:
                return pygame.Rect(
                    self.x + self.tamano[0] - 30,
                    self.y + offset_y,
                    ancho_hitbox, alto_hitbox
                )
            else:
                return pygame.Rect(
                    self.x - ancho_hitbox + 30,
                    self.y + offset_y,
                    ancho_hitbox, alto_hitbox
                )
        return None

    def get_rect(self):
        return pygame.Rect(self.x + 60, self.y + 50, self.tamano[0] - 120, self.tamano[1] - 60)

    def get_rect_bloqueo(self):
        if self.esta_bloqueando:
            if self.mirando_derecha:
                return pygame.Rect(self.x + self.tamano[0] - 30, self.y + 50, 50, 100)
            else:
                return pygame.Rect(self.x - 20, self.y + 50, 50, 100)
        return None

    def dibujar(self, ventana):
        sprite = self.sprite_actual
        if not self.mirando_derecha:
            sprite = pygame.transform.flip(sprite, True, False)

        temp_sprite = sprite.copy()

        if self.esta_recibiendo_dano and (pygame.time.get_ticks() // 100) % 2 == 0:
            temp_surface = pygame.Surface(temp_sprite.get_size(), pygame.SRCALPHA)
            temp_surface.fill((255, 100, 100, 100))
            temp_sprite.blit(temp_surface, (0, 0), special_flags=pygame.BLEND_RGBA_ADD)
        elif self.invencible and (pygame.time.get_ticks() // 100) % 2 == 0:
            temp_surface = pygame.Surface(temp_sprite.get_size(), pygame.SRCALPHA)
            temp_surface.fill((255, 255, 100, 80))
            temp_sprite.blit(temp_surface, (0, 0), special_flags=pygame.BLEND_RGBA_ADD)
        elif self.habilidad_especial.esta_activa():
            temp_surface = pygame.Surface(temp_sprite.get_size(), pygame.SRCALPHA)
            if self.habilidad_especial.tipo == "golpe_cargado":
                temp_surface.fill((255, 200, 0, 60))
            elif self.habilidad_especial.tipo == "dash_ataque":
                temp_surface.fill((0, 200, 255, 60))
            elif self.habilidad_especial.tipo == "bloqueo_fuerte":
                temp_surface.fill((0, 255, 100, 60))
            temp_sprite.blit(temp_surface, (0, 0), special_flags=pygame.BLEND_RGBA_ADD)

        if self.esta_stuneado:
            temp_surface = pygame.Surface(temp_sprite.get_size(), pygame.SRCALPHA)
            temp_surface.fill((200, 200, 255, 100))
            temp_sprite.blit(temp_surface, (0, 0), special_flags=pygame.BLEND_RGBA_ADD)

        ventana.blit(temp_sprite, (self.x, self.y))

        if self.combo_count > 0:
            fuente_combo = pygame.font.SysFont('Arial', 20, bold=True)
            texto_combo = fuente_combo.render(f"COMBO x{self.combo_count + 1}", True, (255, 255, 0))
            ventana.blit(texto_combo, (self.x + self.tamano[0] // 2 - texto_combo.get_width() // 2, self.y - 40))

        color_indicador = self.config_clase["color"]
        pygame.draw.circle(ventana, color_indicador, (int(self.x + self.tamano[0] // 2), int(self.y - 20)), 12)
        pygame.draw.circle(ventana, (255, 255, 255), (int(self.x + self.tamano[0] // 2), int(self.y - 20)), 12, 2)

        if self.habilidad_especial.carga_actual > 0:
            ancho_barra = 60
            alto_barra = 6
            x = self.x + self.tamano[0] // 2 - ancho_barra // 2
            y = self.y - 35

            pygame.draw.rect(ventana, (50, 50, 50), (x, y, ancho_barra, alto_barra))
            carga_porcentaje = self.habilidad_especial.carga_actual / self.habilidad_especial.carga_maxima
            ancho_carga = int(ancho_barra * carga_porcentaje)
            color_carga = (0, 200, 255) if carga_porcentaje < 1.0 else (255, 255, 0)
            pygame.draw.rect(ventana, color_carga, (x, y, ancho_carga, alto_barra))
            pygame.draw.rect(ventana, (255, 255, 255), (x, y, ancho_barra, alto_barra), 1)

    def esta_vivo(self):
        return self.vida_actual > 0

    def aplicar_efecto(self, efecto, duracion, valor=None):
        self.efectos_activos[efecto] = {
            "inicio": pygame.time.get_ticks(),
            "duracion": duracion,
            "valor": valor
        }

    def actualizar_efectos(self):
        tiempo_actual = pygame.time.get_ticks()
        efectos_a_remover = []
        for efecto, datos in self.efectos_activos.items():
            if tiempo_actual - datos["inicio"] > datos["duracion"]:
                efectos_a_remover.append(efecto)
        for efecto in efectos_a_remover:
            self.remover_efecto(efecto)
            del self.efectos_activos[efecto]
        if self.invencible and tiempo_actual > self.tiempo_invencibilidad:
            self.invencible = False

    def remover_efecto(self, efecto):
        if efecto == "velocidad_x1.5":
            self.velocidad_base = self.config_clase["velocidad"]
            self.velocidad = self.velocidad_base

    def saltar(self, sistema_sonido=None):
        if not self.esta_saltando and not self.esta_atacando and not self.esta_recibiendo_dano and not self.esta_stuneado:
            self.velocidad_y = self.fuerza_salto
            self.esta_saltando = True
            if sistema_sonido:
                sistema_sonido.reproducir_sonido('salto')

    def dash(self, direccion):
        if not self.esta_haciendo_dash and not self.esta_atacando and not self.esta_stuneado:
            self.esta_haciendo_dash = True
            self.velocidad = self.velocidad_base * 3
            self.x += direccion * 100
            self.tiempo_dash = pygame.time.get_ticks()

    def actualizar_combo(self):
        """Actualiza el temporizador de combo - MODIFICADO PARA COMBOS INFINITOS"""
        if self.modo_combos_infinitos:
            # En modo combos infinitos, el combo nunca se resetea por tiempo
            # Solo se resetea cuando el jugador es golpeado
            if self.combo_timer > 0:
                self.combo_timer -= 1
        else:
            # Modo normal: el combo se resetea después de un tiempo
            if self.combo_timer > 0:
                self.combo_timer -= 1
            else:
                if self.combo_count > self.estadisticas["max_combo"]:
                    self.estadisticas["max_combo"] = self.combo_count
                self.combo_count = 0

    def ataque_rapido(self, sistema_sonido=None, sistema_particulas=None):
        if not self.esta_atacando and not self.esta_recibiendo_dano and not self.esta_stuneado:
            self.esta_atacando = True
            self.ataque_actual = "rapido"
            self.indice_attack = 0
            self.contador_attack = 0
            self.velocidad_attack = 2

            self.combo_timer = self.combo_max_time
            if self.modo_combos_infinitos:
                # En modo combos infinitos, el combo sigue aumentando indefinidamente
                self.combo_count += 1
            else:
                # Modo normal: combo limitado a 3 niveles
                if self.combo_count < len(self.dano_combo) - 1:
                    self.combo_count += 1
                else:
                    self.combo_count = len(self.dano_combo) - 1

            if sistema_particulas:
                pos_x = self.x + self.tamano[0] if self.mirando_derecha else self.x
                pos_y = self.y + self.tamano[1] // 2
                sistema_particulas.agregar_particulas(pos_x, pos_y, (100, 255, 255), 5, 4, "chorro")

            if sistema_sonido:
                sistema_sonido.reproducir_sonido('golpe_suave')

    def ataque_pesado(self, sistema_sonido=None, sistema_particulas=None):
        if not self.esta_atacando and not self.esta_recibiendo_dano and not self.esta_stuneado:
            self.esta_atacando = True
            self.ataque_actual = "pesado"
            self.indice_attack = 0
            self.contador_attack = 0
            self.velocidad_attack = 5  # Más lento para que sea más poderoso

            # ATAQUES PESADOS NO RESETEAN EL COMBO, SOLO BARUCK
            if self.modo_combos_infinitos:
                # En modo combos infinitos, los ataques pesados mantienen el combo
                self.combo_count += 1  # Aumenta el combo incluso con ataques pesados
            else:
                # En modo normal, los ataques pesados no resetean el combo completamente
                if self.combo_count > 0:
                    self.combo_count = max(0, self.combo_count - 1)  # Solo reduce un nivel

            if sistema_particulas:
                pos_x = self.x + self.tamano[0] if self.mirando_derecha else self.x
                pos_y = self.y + self.tamano[1] // 2
                sistema_particulas.agregar_particulas(pos_x, pos_y, (255, 100, 0), 10, 4, "explosion")  # Más partículas

            if sistema_sonido:
                sistema_sonido.reproducir_sonido('golpe_fuerte')

    def ataque_aereo(self, sistema_sonido=None, sistema_particulas=None):
        if self.esta_saltando and not self.esta_atacando and not self.esta_recibiendo_dano and not self.esta_stuneado:
            self.esta_atacando = True
            self.ataque_actual = "aereo"
            self.indice_attack = 0
            self.contador_attack = 0
            self.velocidad_y = -8  # Empuje hacia arriba

            self.combo_timer = self.combo_max_time
            if self.modo_combos_infinitos:
                self.combo_count += 1
            else:
                self.combo_count = min(self.combo_count + 1, len(self.dano_combo) - 1)

            if sistema_particulas:
                sistema_particulas.agregar_particulas(
                    self.x + self.tamano[0] // 2,
                    self.y,
                    (0, 255, 255), 20, 6, "explosion"  # Más partículas
                )

            if sistema_sonido:
                sistema_sonido.reproducir_sonido('golpe_fuerte')

    def bloquear(self):
        if not self.esta_atacando and not self.esta_recibiendo_dano and not self.esta_stuneado:
            self.esta_bloqueando = True

    def dejar_bloquear(self):
        self.esta_bloqueando = False

    def activar_habilidad(self, sistema_particulas=None, sistema_sonido=None):
        if self.habilidad_especial.activar() and not self.esta_stuneado:
            self.estadisticas["habilidades_usadas"] += 1

            if sistema_sonido:
                sistema_sonido.reproducir_sonido('habilidad')

            if sistema_particulas:
                if self.habilidad_especial.tipo == "golpe_cargado":
                    sistema_particulas.agregar_particulas(
                        self.x + self.tamano[0] // 2,
                        self.y + self.tamano[1] // 2,
                        (255, 200, 0), 25, 7, "explosion"  # Más partículas
                    )
                elif self.habilidad_especial.tipo == "dash_ataque":
                    sistema_particulas.agregar_particulas(
                        self.x + self.tamano[0] // 2,
                        self.y + self.tamano[1] // 2,
                        (0, 200, 255), 20, 10, "chorro"  # Más partículas
                    )
                elif self.habilidad_especial.tipo == "bloqueo_fuerte":
                    sistema_particulas.agregar_particulas(
                        self.x + self.tamano[0] // 2,
                        self.y + self.tamano[1] // 2,
                        (0, 255, 100), 30, 4, "normal"  # Más partículas
                    )
            return True
        return False


# =============================================================================
# SISTEMA DE IA PARA MODO SUPERVIVENCIA
# =============================================================================

class IA_Enemigo:
    def __init__(self, jugador_controlado, jugador_oponente, dificultad=1.0):
        self.jugador = jugador_controlado
        self.oponente = jugador_oponente
        self.dificultad = dificultad
        self.tiempo_ultima_accion = 0
        self.cooldown_accion = random.randint(500, 1500)
        self.estado = "perseguir"  # perseguir, atacar, defender, alejarse

    def actualizar(self):
        tiempo_actual = pygame.time.get_ticks()

        if tiempo_actual - self.tiempo_ultima_accion < self.cooldown_accion:
            return

        distancia_x = abs(self.jugador.x - self.oponente.x)
        distancia_y = abs(self.jugador.y - self.oponente.y)

        # Lógica de IA basada en la distancia y estado
        if distancia_x < 100 and distancia_y < 50:
            # Cercano - atacar
            if self.oponente.esta_atacando and not self.jugador.esta_bloqueando:
                self.jugador.bloquear()
                self.cooldown_accion = 300
            elif not self.jugador.esta_atacando:
                if random.random() < 0.7:
                    self.jugador.ataque_rapido()
                else:
                    if self.jugador.esta_saltando:
                        self.jugador.ataque_aereo()
                    else:
                        self.jugador.ataque_pesado()
                self.cooldown_accion = 800
            self.estado = "atacar"

        elif distancia_x < 300:
            # Media distancia - perseguir
            if self.oponente.x < self.jugador.x:
                self.jugador.mirando_derecha = False
            else:
                self.jugador.mirando_derecha = True

            if random.random() < 0.3 and not self.jugador.esta_saltando:
                self.jugador.saltar()

            self.estado = "perseguir"
            self.cooldown_accion = 200

        else:
            # Lejos - acercarse
            if self.oponente.x < self.jugador.x:
                self.jugador.mirando_derecha = False
            else:
                self.jugador.mirando_derecha = True
            self.estado = "perseguir"
            self.cooldown_accion = 300

        self.tiempo_ultima_accion = tiempo_actual


# =============================================================================
# INTERFACES DE USUARIO
# =============================================================================

class MenuPrincipal:
    def __init__(self, ANCHO, ALTO):
        self.ANCHO = ANCHO
        self.ALTO = ALTO
        self.fuente_titulo = pygame.font.SysFont('Arial', 72, bold=True)
        self.fuente_botones = pygame.font.SysFont('Arial', 32)

        self.botones = [
            {"texto": "JUGAR", "rect": pygame.Rect(0, 0, 300, 60), "accion": "jugar", "color_base": (50, 255, 50)},
            {"texto": "OPCIONES", "rect": pygame.Rect(0, 0, 300, 60), "accion": "opciones",
             "color_base": (100, 150, 255)},
            {"texto": "SALIR", "rect": pygame.Rect(0, 0, 300, 60), "accion": "salir", "color_base": (255, 50, 50)}
        ]

        for i, boton in enumerate(self.botones):
            boton["rect"].center = (self.ANCHO // 2, self.ALTO // 2 + i * 80)

    def dibujar(self, ventana):
        ventana.fill((20, 20, 40))

        titulo = self.fuente_titulo.render("STICK MAN ARENA - VERSION BARUC", True, (255, 255, 255))
        ventana.blit(titulo, (self.ANCHO // 2 - titulo.get_width() // 2, self.ALTO // 4))

        mouse_pos = pygame.mouse.get_pos()
        for boton in self.botones:
            color = boton["color_base"]
            if boton["rect"].collidepoint(mouse_pos):
                color = tuple(min(c + 40, 255) for c in color)

            pygame.draw.rect(ventana, color, boton["rect"], border_radius=20)
            pygame.draw.rect(ventana, (255, 255, 255), boton["rect"], 3, border_radius=20)

            texto = self.fuente_botones.render(boton["texto"], True, (255, 255, 255))
            ventana.blit(texto, (boton["rect"].centerx - texto.get_width() // 2,
                                 boton["rect"].centery - texto.get_height() // 2))

    def manejar_evento(self, evento, sistema_sonido):
        if evento.type == pygame.QUIT:
            return "salir"
        if evento.type == pygame.KEYDOWN:
            if evento.key == pygame.K_ESCAPE:
                return "salir"
            if evento.key == pygame.K_RETURN:
                sistema_sonido.reproducir_sonido('menu_select')
                return "jugar"
        if evento.type == pygame.MOUSEBUTTONDOWN:
            if evento.button == 1:
                for boton in self.botones:
                    if boton["rect"].collidepoint(evento.pos):
                        sistema_sonido.reproducir_sonido('menu_select')
                        return boton["accion"]
        return None


class MenuSeleccionModo:
    def __init__(self, ANCHO, ALTO):
        self.ANCHO = ANCHO
        self.ALTO = ALTO
        self.fuente_titulo = pygame.font.SysFont('Arial', 48, bold=True)
        self.fuente_botones = pygame.font.SysFont('Arial', 28)
        self.fuente_desc = pygame.font.SysFont('Arial', 18)

        self.botones = []
        y_pos = ALTO // 3
        for modo in ModoJuego:
            config = CONFIG_MODOS[modo]
            self.botones.append({
                "modo": modo,
                "texto": config["nombre"],
                "descripcion": config["descripcion"],
                "rect": pygame.Rect(0, 0, 500, 60),
                "color_base": (70, 130, 200)
            })
            y_pos += 100

        for i, boton in enumerate(self.botones):
            boton["rect"].center = (self.ANCHO // 2, self.ALTO // 3 + i * 100)

        self.boton_volver = pygame.Rect(50, ALTO - 80, 200, 50)

    def dibujar(self, ventana):
        ventana.fill((30, 30, 60))

        titulo = self.fuente_titulo.render("SELECCIONA MODO DE JUEGO", True, (255, 255, 255))
        ventana.blit(titulo, (self.ANCHO // 2 - titulo.get_width() // 2, 80))

        mouse_pos = pygame.mouse.get_pos()
        for boton in self.botones:
            color = boton["color_base"]
            if boton["rect"].collidepoint(mouse_pos):
                color = tuple(min(c + 40, 255) for c in color)

            pygame.draw.rect(ventana, color, boton["rect"], border_radius=15)
            pygame.draw.rect(ventana, (255, 255, 255), boton["rect"], 3, border_radius=15)

            texto = self.fuente_botones.render(boton["texto"], True, (255, 255, 255))
            ventana.blit(texto, (boton["rect"].centerx - texto.get_width() // 2,
                                 boton["rect"].centery - texto.get_height() // 2 - 8))

            desc = self.fuente_desc.render(boton["descripcion"], True, (200, 200, 200))
            ventana.blit(desc, (boton["rect"].centerx - desc.get_width() // 2,
                                boton["rect"].centery + 10))

        # Botón volver
        color_volver = (200, 100, 100)
        if self.boton_volver.collidepoint(mouse_pos):
            color_volver = (255, 120, 120)
        pygame.draw.rect(ventana, color_volver, self.boton_volver, border_radius=10)
        pygame.draw.rect(ventana, (255, 255, 255), self.boton_volver, 2, border_radius=10)
        texto_volver = self.fuente_botones.render("VOLVER", True, (255, 255, 255))
        ventana.blit(texto_volver, (self.boton_volver.centerx - texto_volver.get_width() // 2,
                                    self.boton_volver.centery - texto_volver.get_height() // 2))

    def manejar_evento(self, evento, sistema_sonido):
        if evento.type == pygame.QUIT:
            return "salir"
        if evento.type == pygame.KEYDOWN:
            if evento.key == pygame.K_ESCAPE:
                sistema_sonido.reproducir_sonido('menu_select')
                return "menu"
        if evento.type == pygame.MOUSEBUTTONDOWN:
            if evento.button == 1:
                for boton in self.botones:
                    if boton["rect"].collidepoint(evento.pos):
                        sistema_sonido.reproducir_sonido('menu_select')
                        return boton["modo"]
                if self.boton_volver.collidepoint(evento.pos):
                    sistema_sonido.reproducir_sonido('menu_select')
                    return "menu"
        return None


class MenuSeleccionPersonaje:
    def __init__(self, ANCHO, ALTO):
        self.ANCHO = ANCHO
        self.ALTO = ALTO
        self.personaje_seleccionado_j1 = "guerrero"
        self.personaje_seleccionado_j2 = "asesino"
        self.fuente_titulo = pygame.font.SysFont('Arial', 48, bold=True)
        self.fuente = pygame.font.SysFont('Arial', 28)
        self.fuente_stats = pygame.font.SysFont('Arial', 20)
        self.fuente_desc = pygame.font.SysFont('Arial', 18)

        self.boton_empezar = pygame.Rect(ANCHO // 2 - 100, ALTO - 100, 200, 60)
        self.boton_volver = pygame.Rect(50, ALTO - 80, 200, 50)

    def dibujar(self, ventana):
        ventana.fill((30, 30, 60))

        titulo = self.fuente_titulo.render("SELECCIÓN DE PERSONAJE", True, (255, 255, 255))
        ventana.blit(titulo, (self.ANCHO // 2 - titulo.get_width() // 2, 50))

        x_positions = [self.ANCHO // 4, 3 * self.ANCHO // 4]
        selecciones = [self.personaje_seleccionado_j1, self.personaje_seleccionado_j2]
        jugadores = ["JUGADOR 1", "JUGADOR 2"]

        mouse_pos = pygame.mouse.get_pos()

        for i, (x, personaje, jugador) in enumerate(zip(x_positions, selecciones, jugadores)):
            color = (100, 200, 255) if i == 0 else (255, 100, 100)
            pygame.draw.rect(ventana, color, (x - 120, 150, 240, 300), 3, border_radius=15)

            texto_jugador = self.fuente.render(jugador, True, color)
            ventana.blit(texto_jugador, (x - texto_jugador.get_width() // 2, 120))

            info = CLASES_PERSONAJE[personaje]
            nombre = self.fuente.render(info["nombre"], True, color)
            ventana.blit(nombre, (x - nombre.get_width() // 2, 470))

            stats = [
                f"Vida: {info['vida']}",
                f"Velocidad: {info['velocidad']}",
                f"Daño: {info['dano_base']}",
                f"Habilidad: {info['habilidad']}"
            ]
            for j, stat in enumerate(stats):
                stat_text = self.fuente_stats.render(stat, True, (200, 200, 200))
                ventana.blit(stat_text, (x - stat_text.get_width() // 2, 500 + j * 30))

            desc_lines = self.wrap_text(info["descripcion"], self.fuente_desc, 200)
            for j, line in enumerate(desc_lines):
                desc_text = self.fuente_desc.render(line, True, (150, 150, 150))
                ventana.blit(desc_text, (x - desc_text.get_width() // 2, 500 + len(stats) * 30 + j * 20))

            # Flechas de selección
            if i == 0:
                # Flechas izquierda
                pygame.draw.polygon(ventana, color, [(x - 150, 300), (x - 170, 280), (x - 170, 320)])
                # Flechas derecha
                pygame.draw.polygon(ventana, color, [(x + 150, 300), (x + 170, 280), (x + 170, 320)])
            else:
                # Flechas izquierda (pero para jugador 2)
                pygame.draw.polygon(ventana, color, [(x - 150, 300), (x - 170, 280), (x - 170, 320)])
                # Flechas derecha
                pygame.draw.polygon(ventana, color, [(x + 150, 300), (x + 170, 280), (x + 170, 320)])

        # Botón empezar
        color_empezar = (50, 255, 50)
        if self.boton_empezar.collidepoint(mouse_pos):
            color_empezar = (100, 255, 100)
        pygame.draw.rect(ventana, color_empezar, self.boton_empezar, border_radius=15)
        pygame.draw.rect(ventana, (255, 255, 255), self.boton_empezar, 3, border_radius=15)
        texto_empezar = self.fuente.render("EMPEZAR", True, (255, 255, 255))
        ventana.blit(texto_empezar, (self.boton_empezar.centerx - texto_empezar.get_width() // 2,
                                     self.boton_empezar.centery - texto_empezar.get_height() // 2))

        # Botón volver
        color_volver = (200, 100, 100)
        if self.boton_volver.collidepoint(mouse_pos):
            color_volver = (255, 120, 120)
        pygame.draw.rect(ventana, color_volver, self.boton_volver, border_radius=10)
        pygame.draw.rect(ventana, (255, 255, 255), self.boton_volver, 2, border_radius=10)
        texto_volver = self.fuente.render("VOLVER", True, (255, 255, 255))
        ventana.blit(texto_volver, (self.boton_volver.centerx - texto_volver.get_width() // 2,
                                    self.boton_volver.centery - texto_volver.get_height() // 2))

    def wrap_text(self, text, font, max_width):
        words = text.split(' ')
        lines = []
        current_line = []
        for word in words:
            test_line = ' '.join(current_line + [word])
            test_width = font.size(test_line)[0]
            if test_width <= max_width:
                current_line.append(word)
            else:
                lines.append(' '.join(current_line))
                current_line = [word]
        if current_line:
            lines.append(' '.join(current_line))
        return lines

    def manejar_evento(self, evento, sistema_sonido):
        if evento.type == pygame.QUIT:
            return "salir"
        if evento.type == pygame.KEYDOWN:
            if evento.key == pygame.K_ESCAPE:
                sistema_sonido.reproducir_sonido('menu_select')
                return "menu"
            if evento.key == pygame.K_RETURN:
                sistema_sonido.reproducir_sonido('menu_select')
                return "empezar"

        if evento.type == pygame.MOUSEBUTTONDOWN:
            if evento.button == 1:
                mouse_pos = evento.pos
                # Verificar flechas jugador 1
                x_j1 = self.ANCHO // 4
                if self.punto_en_triangulo(mouse_pos, (x_j1 - 150, 300), (x_j1 - 170, 280), (x_j1 - 170, 320)):
                    self.cambiar_personaje(1, -1)
                    sistema_sonido.reproducir_sonido('menu_select')
                if self.punto_en_triangulo(mouse_pos, (x_j1 + 150, 300), (x_j1 + 170, 280), (x_j1 + 170, 320)):
                    self.cambiar_personaje(1, 1)
                    sistema_sonido.reproducir_sonido('menu_select')

                # Verificar flechas jugador 2
                x_j2 = 3 * self.ANCHO // 4
                if self.punto_en_triangulo(mouse_pos, (x_j2 - 150, 300), (x_j2 - 170, 280), (x_j2 - 170, 320)):
                    self.cambiar_personaje(2, -1)
                    sistema_sonido.reproducir_sonido('menu_select')
                if self.punto_en_triangulo(mouse_pos, (x_j2 + 150, 300), (x_j2 + 170, 280), (x_j2 + 170, 320)):
                    self.cambiar_personaje(2, 1)
                    sistema_sonido.reproducir_sonido('menu_select')

                # Verificar botón empezar
                if self.boton_empezar.collidepoint(mouse_pos):
                    sistema_sonido.reproducir_sonido('menu_select')
                    return "empezar"

                # Verificar botón volver
                if self.boton_volver.collidepoint(mouse_pos):
                    sistema_sonido.reproducir_sonido('menu_select')
                    return "menu"

        return None

    def cambiar_personaje(self, jugador, direccion):
        clases = list(CLASES_PERSONAJE.keys())
        if jugador == 1:
            indice_actual = clases.index(self.personaje_seleccionado_j1)
            nuevo_indice = (indice_actual + direccion) % len(clases)
            self.personaje_seleccionado_j1 = clases[nuevo_indice]
        else:
            indice_actual = clases.index(self.personaje_seleccionado_j2)
            nuevo_indice = (indice_actual + direccion) % len(clases)
            self.personaje_seleccionado_j2 = clases[nuevo_indice]

    def punto_en_triangulo(self, p, a, b, c):
        def sign(p1, p2, p3):
            return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])

        d1 = sign(p, a, b)
        d2 = sign(p, b, c)
        d3 = sign(p, c, a)

        has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)
        has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)

        return not (has_neg and has_pos)


class MenuOpciones:
    def __init__(self, ANCHO, ALTO, sistema_config):
        self.ANCHO = ANCHO
        self.ALTO = ALTO
        self.config = sistema_config
        self.fuente_titulo = pygame.font.SysFont('Arial', 48, bold=True)
        self.fuente = pygame.font.SysFont('Arial', 28)
        self.fuente_pequena = pygame.font.SysFont('Arial', 20)

        self.categoria_actual = "graficos"
        self.opcion_seleccionada = 0
        self.categorias = ["graficos", "audio", "controles", "gameplay"]
        self.boton_volver = pygame.Rect(50, ALTO - 80, 200, 50)
        self.boton_aplicar = pygame.Rect(ANCHO - 250, ALTO - 80, 200, 50)

    def dibujar(self, ventana):
        ventana.fill((30, 30, 60))

        # Título
        titulo = self.fuente_titulo.render("OPCIONES", True, (255, 255, 255))
        ventana.blit(titulo, (self.ANCHO // 2 - titulo.get_width() // 2, 40))

        # Categorías
        x_categorias = 100
        for i, categoria in enumerate(self.categorias):
            color = (100, 200, 255) if categoria == self.categoria_actual else (150, 150, 150)
            texto = self.fuente.render(categoria.upper(), True, color)
            ventana.blit(texto, (x_categorias, 120))
            x_categorias += texto.get_width() + 40

        # Opciones de la categoría actual
        self.dibujar_opciones_categoria(ventana)

        # Botones
        mouse_pos = pygame.mouse.get_pos()

        # Botón volver
        color_volver = (200, 100, 100) if self.boton_volver.collidepoint(mouse_pos) else (150, 70, 70)
        pygame.draw.rect(ventana, color_volver, self.boton_volver, border_radius=10)
        pygame.draw.rect(ventana, (255, 255, 255), self.boton_volver, 2, border_radius=10)
        texto_volver = self.fuente.render("VOLVER", True, (255, 255, 255))
        ventana.blit(texto_volver, (self.boton_volver.centerx - texto_volver.get_width() // 2,
                                    self.boton_volver.centery - texto_volver.get_height() // 2))

        # Botón aplicar
        color_aplicar = (50, 200, 50) if self.boton_aplicar.collidepoint(mouse_pos) else (30, 150, 30)
        pygame.draw.rect(ventana, color_aplicar, self.boton_aplicar, border_radius=10)
        pygame.draw.rect(ventana, (255, 255, 255), self.boton_aplicar, 2, border_radius=10)
        texto_aplicar = self.fuente.render("APLICAR", True, (255, 255, 255))
        ventana.blit(texto_aplicar, (self.boton_aplicar.centerx - texto_aplicar.get_width() // 2,
                                     self.boton_aplicar.centery - texto_aplicar.get_height() // 2))

    def dibujar_opciones_categoria(self, ventana):
        y = 180
        opciones = self.obtener_opciones_categoria()

        for i, (opcion, valor_actual) in enumerate(opciones):
            color = (255, 255, 0) if i == self.opcion_seleccionada else (255, 255, 255)

            # Nombre de la opción
            texto_opcion = self.fuente.render(opcion.replace('_', ' ').title(), True, color)
            ventana.blit(texto_opcion, (150, y))

            # Valor actual
            if isinstance(valor_actual, bool):
                texto_valor = "ON" if valor_actual else "OFF"
                color_valor = (50, 255, 50) if valor_actual else (255, 50, 50)
            elif isinstance(valor_actual, (int, float)):
                texto_valor = str(valor_actual)
                color_valor = (200, 200, 100)
            else:
                texto_valor = str(valor_actual)
                color_valor = (200, 200, 200)

            texto_valor_render = self.fuente.render(texto_valor, True, color_valor)
            ventana.blit(texto_valor_render, (500, y))

            # Flechas para cambiar valor
            if i == self.opcion_seleccionada:
                pygame.draw.polygon(ventana, (255, 255, 255),
                                    [(450, y + 15), (430, y + 5), (430, y + 25)])  # Izquierda
                pygame.draw.polygon(ventana, (255, 255, 255),
                                    [(550, y + 15), (570, y + 5), (570, y + 25)])  # Derecha

            y += 50

    def obtener_opciones_categoria(self):
        config_categoria = self.config.config[self.categoria_actual]
        opciones = []

        for clave, valor in config_categoria.items():
            if isinstance(valor, dict):
                for sub_clave, sub_valor in valor.items():
                    opciones.append((f"{clave}_{sub_clave}", sub_valor))
            else:
                opciones.append((clave, valor))

        return opciones

    def manejar_evento(self, evento, sistema_sonido):
        if evento.type == pygame.QUIT:
            return "salir"

        if evento.type == pygame.KEYDOWN:
            if evento.key == pygame.K_ESCAPE:
                sistema_sonido.reproducir_sonido('menu_select')
                return "menu"

            elif evento.key == pygame.K_UP:
                self.opcion_seleccionada = max(0, self.opcion_seleccionada - 1)
                sistema_sonido.reproducir_sonido('menu_select')

            elif evento.key == pygame.K_DOWN:
                opciones = self.obtener_opciones_categoria()
                self.opcion_seleccionada = min(len(opciones) - 1, self.opcion_seleccionada + 1)
                sistema_sonido.reproducir_sonido('menu_select')

            elif evento.key == pygame.K_LEFT:
                self.cambiar_valor(-1)
                sistema_sonido.reproducir_sonido('menu_select')

            elif evento.key == pygame.K_RIGHT:
                self.cambiar_valor(1)
                sistema_sonido.reproducir_sonido('menu_select')

            elif evento.key == pygame.K_RETURN:
                sistema_sonido.reproducir_sonido('menu_select')
                return "aplicar"

        if evento.type == pygame.MOUSEBUTTONDOWN:
            mouse_pos = evento.pos

            # Verificar categorías
            x_categorias = 100
            for i, categoria in enumerate(self.categorias):
                texto = self.fuente.render(categoria.upper(), True, (255, 255, 255))
                rect_categoria = pygame.Rect(x_categorias, 120, texto.get_width(), texto.get_height())
                if rect_categoria.collidepoint(mouse_pos):
                    self.categoria_actual = categoria
                    self.opcion_seleccionada = 0
                    sistema_sonido.reproducir_sonido('menu_select')
                    break
                x_categorias += texto.get_width() + 40

            # Verificar botones
            if self.boton_volver.collidepoint(mouse_pos):
                sistema_sonido.reproducir_sonido('menu_select')
                return "menu"

            if self.boton_aplicar.collidepoint(mouse_pos):
                sistema_sonido.reproducir_sonido('menu_select')
                return "aplicar"

        return None

    def cambiar_valor(self, direccion):
        try:
            opciones = self.obtener_opciones_categoria()
            if not opciones or self.opcion_seleccionada >= len(opciones):
                return

            opcion_actual, valor_actual = opciones[self.opcion_seleccionada]

            # Para categorías simples (sin subniveles)
            if self.categoria_actual in ["graficos", "audio", "gameplay"]:
                if opcion_actual in self.config.config[self.categoria_actual]:
                    self._cambiar_valor_simple(self.categoria_actual, opcion_actual, valor_actual, direccion)

            # Para controles (que tiene subniveles)
            elif self.categoria_actual == "controles":
                if '_' in opcion_actual:
                    partes = opcion_actual.split('_', 1)  # Dividir solo una vez
                    if len(partes) == 2:
                        jugador, accion = partes
                        if (jugador in self.config.config["controles"] and
                                accion in self.config.config["controles"][jugador]):
                            valor_actual = self.config.config["controles"][jugador][accion]
                            self._cambiar_valor_controles(jugador, accion, valor_actual, direccion)

        except Exception as e:
            print(f"❌ Error cambiando valor: {e}")

    def _cambiar_valor_simple(self, categoria, clave, valor_actual, direccion):
        """Cambia valores para categorías simples (sin subniveles)"""
        if isinstance(valor_actual, bool):
            self.config.config[categoria][clave] = not valor_actual
        elif isinstance(valor_actual, int):
            if "volumen" in clave:
                nuevo_valor = max(0, min(100, valor_actual + direccion * 10))
            else:
                nuevo_valor = valor_actual + direccion
            self.config.config[categoria][clave] = nuevo_valor
        elif isinstance(valor_actual, float):
            if "volumen" in clave:
                nuevo_valor = max(0.0, min(1.0, valor_actual + direccion * 0.1))
            else:
                nuevo_valor = valor_actual + direccion * 0.1
            self.config.config[categoria][clave] = round(nuevo_valor, 1)

    def _cambiar_valor_controles(self, jugador, accion, valor_actual, direccion):
        """Cambia valores para controles (maneja reasignación de teclas)"""
        # Para controles, necesitaríamos un sistema de reasignación más complejo
        # Por ahora, solo permitimos cambiar mediante un sistema de diálogo
        print(f"ℹ️  Reasignación de teclas para {jugador}.{accion} no implementada")
        # En un futuro: abrir diálogo para esperar nueva tecla


# =============================================================================
# CLASE JUEGO PRINCIPAL CON MODO SUPERVIVENCIA POR OLEADAS
# =============================================================================

class Juego:
    def __init__(self, ANCHO, ALTO):
        self.ANCHO = ANCHO
        self.ALTO = ALTO
        self.recursos_cargados = False
        self.frames_fondo = None
        self.frames_idle = None
        self.frames_run = None
        self.frames_attack = None
        self.frames_hit = None
        self.TAMANO_PERSONAJE = (250, 250)  # DEFINIDO AL INICIO

        # Sistema de juego
        self.modo_actual = ModoJuego.CLASICO
        self.config_modo = CONFIG_MODOS[ModoJuego.CLASICO]
        self.sistema_progresion = SistemaProgresion()

        # Jugadores
        self.jugador1 = None
        self.jugador2 = None
        self.clase_jugador1 = "guerrero"
        self.clase_jugador2 = "asesino"

        # Sistemas mejorados
        self.camara = Camara(ANCHO, ALTO)
        self.sistema_feedback = SistemaFeedbackSatisfaccion(self.camara)
        self.sistema_momentum = SistemaMomentum()
        self.mecanicas_clutch = MecanicasClutch()
        self.sistema_stun = SistemaStun()
        self.sistema_estilo = SistemaEstilo()
        self.sistema_particulas = SistemaParticulas()
        self.sistema_sonido = SistemaSonido()
        self.sistema_tutorial = SistemaTutorial()
        self.sistema_combos_visual = SistemaCombosVisual()
        self.administrador_recursos = AdministradorRecursos()
        self.sistema_config = SistemaConfiguracion()

        # Power-ups y plataformas
        self.powerups = []
        self.plataformas = []
        self.tiempo_ultimo_powerup = 0
        self.intervalo_powerups = 8000

        # Animación del fondo
        self.indice_fondo = 0
        self.velocidad_fondo = 6
        self.contador_fondo = 0

        # Estadísticas globales
        self.estadisticas_globales = {
            "partidas_jugadas": 0,
            "victorias_j1": 0,
            "victorias_j2": 0,
            "empates": 0,
            "total_golpes": 0,
            "max_combo_global": 0,
            "puntos_estilo_j1": 0,
            "puntos_estilo_j2": 0
        }

        # Sistema de Vidas
        self.stocks_j1 = 3
        self.stocks_j2 = 3

        # NUEVO: Sistema de oleadas para modo Supervivencia
        self.oleada_actual = 1
        self.enemigos_derrotados_oleada = 0
        self.enemigos_necesarios_oleada = 3  # Comienza con 3 enemigos por oleada
        self.ia_enemigo = None
        self.tiempo_inicio_oleada = 0
        self.oleada_completada = False

        # NUEVO: Temporizador entre oleadas
        self.tiempo_entre_oleadas = 3000  # 3 segundos entre oleadas
        self.en_transicion_oleada = False
        self.tiempo_fin_oleada = 0

        self.cargar_estadisticas()
        self.aplicar_configuracion_completa()

    def cargar_estadisticas(self):
        try:
            with open("estadisticas.json", "r") as f:
                self.estadisticas_globales = json.load(f)
        except:
            pass

    def guardar_estadisticas(self):
        try:
            with open("estadisticas.json", "w") as f:
                json.dump(self.estadisticas_globales, f)
        except:
            pass

    def aplicar_configuracion_completa(self):
        self.sistema_config.aplicar_configuracion_audio(self.sistema_sonido)

    def cargar_recursos_si_es_necesario(self):
        if not self.recursos_cargados:
            try:
                # Cargar fondos reales
                self.frames_fondo = []
                for i in range(1, 9):  # 8 fondos
                    try:
                        fondo = pygame.image.load(f"sprites/fondos/fondo_{i}.png")
                        fondo = pygame.transform.scale(fondo, (self.ANCHO, self.ALTO))
                        self.frames_fondo.append(fondo)
                    except:
                        print(f"⚠️ No se pudo cargar fondo {i}, usando placeholder")
                        self.frames_fondo.append(self.crear_fondo_placeholder())

                # Cargar sprites por clase de personaje
                self.sprites_por_clase = {}
                for clase in CLASES_PERSONAJE.keys():
                    try:
                        self.sprites_por_clase[clase] = {
                            'idle': self.cargar_animacion(f"sprites/personajes/{clase}/idle_", 3),
                            'run': self.cargar_animacion(f"sprites/personajes/{clase}/run_", 4),
                            'attack': self.cargar_animacion(f"sprites/personajes/{clase}/attack_", 3),
                            'hit': self.cargar_animacion(f"sprites/personajes/{clase}/hit_", 2)
                        }
                    except Exception as e:
                        print(f"⚠️ Error cargando sprites para {clase}: {e}")
                        # Usar placeholders si falla
                        self.sprites_por_clase[clase] = {
                            'idle': [self.crear_sprite_placeholder() for _ in range(3)],
                            'run': [self.crear_sprite_placeholder() for _ in range(4)],
                            'attack': [self.crear_sprite_placeholder() for _ in range(3)],
                            'hit': [self.crear_sprite_placeholder() for _ in range(2)]
                        }

                # Usar sprites del guerrero como default (para compatibilidad)
                if 'guerrero' in self.sprites_por_clase:
                    sprites_default = self.sprites_por_clase['guerrero']
                else:
                    # Si no hay guerrero, crear placeholders
                    sprites_default = {
                        'idle': [self.crear_sprite_placeholder() for _ in range(3)],
                        'run': [self.crear_sprite_placeholder() for _ in range(4)],
                        'attack': [self.crear_sprite_placeholder() for _ in range(3)],
                        'hit': [self.crear_sprite_placeholder() for _ in range(2)]
                    }

                self.frames_idle = sprites_default['idle']
                self.frames_run = sprites_default['run']
                self.frames_attack = sprites_default['attack']
                self.frames_hit = sprites_default['hit']

            except Exception as e:
                print(f"❌ Error crítico cargando recursos: {e}")
                print("🔄 Usando placeholders...")
                # Crear todos los placeholders directamente
                self.frames_fondo = [self.crear_fondo_placeholder() for _ in range(8)]
                self.frames_idle = [self.crear_sprite_placeholder() for _ in range(3)]
                self.frames_run = [self.crear_sprite_placeholder() for _ in range(4)]
                self.frames_attack = [self.crear_sprite_placeholder() for _ in range(3)]
                self.frames_hit = [self.crear_sprite_placeholder() for _ in range(2)]

            self.sistema_sonido.cargar_sonidos()
            self.sistema_sonido.reproducir_musica()
            self.recursos_cargados = True

        self.resetear_juego()

    def cargar_animacion(self, ruta_base, cantidad_frames):
        """Carga una animación desde múltiples archivos"""
        frames = []
        for i in range(1, cantidad_frames + 1):
            try:
                img = pygame.image.load(f"{ruta_base}{i}.png")
                img = pygame.transform.scale(img, self.TAMANO_PERSONAJE)
                frames.append(img.convert_alpha())
            except:
                # Si falla la carga, usar placeholder
                frames.append(self.crear_sprite_placeholder())
        return frames

    def crear_fondo_placeholder(self):
        surf = pygame.Surface((self.ANCHO, self.ALTO))
        color_base = (random.randint(20, 40), random.randint(20, 40), random.randint(50, 70))
        surf.fill(color_base)

        # Agregar algunas estrellas/partículas para el fondo
        for _ in range(50):
            x = random.randint(0, self.ANCHO)
            y = random.randint(0, self.ALTO)
            radio = random.randint(1, 3)
            brillo = random.randint(150, 255)
            pygame.draw.circle(surf, (brillo, brillo, brillo), (x, y), radio)

        return surf

    def crear_sprite_placeholder(self):
        surf = pygame.Surface(self.TAMANO_PERSONAJE, pygame.SRCALPHA)
        color = (random.randint(100, 200), random.randint(100, 200), random.randint(100, 200))

        # Cuerpo
        pygame.draw.rect(surf, color, (80, 80, 90, 120), border_radius=20)

        # Cabeza
        pygame.draw.circle(surf, color, (125, 60), 30)

        # Brazos y piernas (simplificados)
        pygame.draw.rect(surf, color, (50, 100, 40, 15), border_radius=5)  # Brazo izquierdo
        pygame.draw.rect(surf, color, (160, 100, 40, 15), border_radius=5)  # Brazo derecho
        pygame.draw.rect(surf, color, (100, 200, 20, 50), border_radius=5)  # Pierna izquierda
        pygame.draw.rect(surf, color, (130, 200, 20, 50), border_radius=5)  # Pierna derecha

        return surf

    def configurar_modo(self, modo):
        self.modo_actual = modo
        self.config_modo = CONFIG_MODOS[modo]

        # Configurar modo Supervivencia
        if modo == ModoJuego.SUPERVIVENCIA:
            self.oleada_actual = 1
            self.enemigos_derrotados_oleada = 0
            self.enemigos_necesarios_oleada = 3
            self.ia_enemigo = None
            self.tiempo_inicio_oleada = pygame.time.get_ticks()
            self.oleada_completada = False
            self.en_transicion_oleada = False

    def configurar_personajes(self, clase_j1, clase_j2):
        self.clase_jugador1 = clase_j1
        self.clase_jugador2 = clase_j2

    def generar_plataformas(self):
        self.plataformas = []
        self.plataformas.append(Plataforma(0, self.ALTO - 50, self.ANCHO, 50, "estatica", (100, 70, 40)))

    def resetear_juego(self):
        if not self.recursos_cargados:
            return

        self.stocks_j1 = 3
        self.stocks_j2 = 3

        # Obtener sprites de la clase correcta
        sprites_j1 = self.sprites_por_clase.get(self.clase_jugador1, self.sprites_por_clase.get("guerrero"))
        sprites_j2 = self.sprites_por_clase.get(self.clase_jugador2, self.sprites_por_clase.get("asesino"))

        # Pasar modo_combos_infinitos a los jugadores
        modo_combos_infinitos = (self.modo_actual == ModoJuego.COMBOS_INFINITOS)

        self.jugador1 = Jugador(
            100, self.ALTO - self.TAMANO_PERSONAJE[1],
            sprites_j1['idle'], sprites_j1['run'], sprites_j1['attack'], sprites_j1['hit'],
            self.TAMANO_PERSONAJE, "jugador1", self.clase_jugador1, self.sistema_progresion,
            modo_combos_infinitos
        )

        self.jugador2 = Jugador(
            self.ANCHO - 350, self.ALTO - self.TAMANO_PERSONAJE[1],
            sprites_j2['idle'], sprites_j2['run'], sprites_j2['attack'], sprites_j2['hit'],
            self.TAMANO_PERSONAJE, "jugador2", self.clase_jugador2, self.sistema_progresion,
            modo_combos_infinitos
        )

        self.jugador2.mirando_derecha = False

        # Si es modo Supervivencia, crear IA para el jugador2
        if self.modo_actual == ModoJuego.SUPERVIVENCIA:
            self.ia_enemigo = IA_Enemigo(self.jugador2, self.jugador1, self.oleada_actual * 0.2)
            # Mejorar enemigo según oleada
            self.mejorar_enemigo_por_oleada()

        self.sistema_tutorial.mostrar_mensaje("movimiento")
        self.sistema_tutorial.mostrar_mensaje("objetivo")

        self.generar_plataformas()
        self.powerups = []
        self.tiempo_ultimo_powerup = pygame.time.get_ticks()

    def mejorar_enemigo_por_oleada(self):
        """Mejora las estadísticas del enemigo según la oleada actual"""
        if self.jugador2 and self.modo_actual == ModoJuego.SUPERVIVENCIA:
            factor_mejora = 1.0 + (self.oleada_actual - 1) * 0.2  # 20% más por oleada

            self.jugador2.vida_base *= factor_mejora
            self.jugador2.vida_maxima = self.jugador2.vida_base
            self.jugador2.vida_actual = self.jugador2.vida_maxima

            self.jugador2.dano_base *= factor_mejora
            self.jugador2.velocidad_base *= min(1.0 + (self.oleada_actual - 1) * 0.1, 1.5)  # Máximo 50% más rápido

            # Resetear porcentaje de daño
            self.jugador2.porcentaje_dano = 0

    def obtener_teclas_actualizadas(self):
        teclas = pygame.key.get_pressed()
        config_controles = self.sistema_config.config["controles"]

        # Crear una función lambda que maneje el mapeo CORREGIDO
        def tecla_presionada(key):
            # Mapeo directo de teclas físicas a acciones
            if key == pygame.K_LEFT:
                return teclas[config_controles["jugador1"]["izquierda"]]
            elif key == pygame.K_RIGHT:
                return teclas[config_controles["jugador1"]["derecha"]]
            elif key == pygame.K_UP:
                return teclas[config_controles["jugador1"]["arriba"]]
            elif key == pygame.K_SPACE:
                return teclas[config_controles["jugador1"]["ataque_rapido"]]
            elif key == pygame.K_LSHIFT:
                return teclas[config_controles["jugador1"]["ataque_pesado"]]
            elif key == pygame.K_q:
                return teclas[config_controles["jugador1"]["habilidad"]]
            elif key == pygame.K_x:
                return teclas[config_controles["jugador1"]["bloqueo"]]
            elif key == pygame.K_a:
                return teclas[config_controles["jugador2"]["izquierda"]]
            elif key == pygame.K_d:
                return teclas[config_controles["jugador2"]["derecha"]]
            elif key == pygame.K_w:
                return teclas[config_controles["jugador2"]["arriba"]]
            elif key == pygame.K_f:
                return teclas[config_controles["jugador2"]["ataque_rapido"]]
            elif key == pygame.K_r:
                return teclas[config_controles["jugador2"]["ataque_pesado"]]
            elif key == pygame.K_e:
                return teclas[config_controles["jugador2"]["habilidad"]]
            elif key == pygame.K_g:
                return teclas[config_controles["jugador2"]["bloqueo"]]
            return False

        return tecla_presionada

    def actualizar(self):
        if not self.recursos_cargados or self.jugador1 is None or self.jugador2 is None:
            return

        self.contador_fondo += 1
        if self.contador_fondo >= self.velocidad_fondo:
            self.contador_fondo = 0
            if self.frames_fondo:
                self.indice_fondo = (self.indice_fondo + 1) % len(self.frames_fondo)

        teclas_func = self.obtener_teclas_actualizadas()

        # Verificar transición entre oleadas (modo Supervivencia)
        if self.modo_actual == ModoJuego.SUPERVIVENCIA and self.en_transicion_oleada:
            tiempo_actual = pygame.time.get_ticks()
            if tiempo_actual - self.tiempo_fin_oleada >= self.tiempo_entre_oleadas:
                self.en_transicion_oleada = False
                self.comenzar_nueva_oleada()
            else:
                # Durante la transición, solo actualizar efectos visuales
                self.sistema_particulas.actualizar()
                self.sistema_feedback.actualizar()
                return

        self.actualizar_sistemas_mejorados(teclas_func)

        # Actualizar IA enemiga si está activa (modo Supervivencia)
        if self.modo_actual == ModoJuego.SUPERVIVENCIA and self.ia_enemigo:
            self.ia_enemigo.actualizar()

        self.jugador1.actualizar(teclas_func, self.ANCHO, self.ALTO, self.plataformas, limite_der=self.ANCHO)
        self.jugador2.actualizar(teclas_func, self.ANCHO, self.ALTO, self.plataformas, limite_der=self.ANCHO)

        self.verificar_colisiones_ataques()
        self.verificar_muertes()

        # Verificar si se completó la oleada (modo Supervivencia)
        if self.modo_actual == ModoJuego.SUPERVIVENCIA and not self.oleada_completada:
            self.verificar_completado_oleada()

    def actualizar_sistemas_mejorados(self, teclas):
        self.sistema_momentum.actualizar_momentum(self.jugador1, self.jugador2)
        self.sistema_stun.actualizar(teclas)
        self.mecanicas_clutch.verificar_situacion_clutch(self.jugador1, self.stocks_j1, self.jugador1.porcentaje_dano)
        self.mecanicas_clutch.verificar_situacion_clutch(self.jugador2, self.stocks_j2, self.jugador2.porcentaje_dano)
        self.mecanicas_clutch.actualizar(self.jugador1, self.jugador2)
        self.sistema_feedback.actualizar()
        self.sistema_estilo.actualizar()
        self.sistema_particulas.actualizar()
        self.sistema_tutorial.actualizar()
        self.camara.actualizar()

    def verificar_colisiones_ataques(self):
        hitbox1 = self.jugador1.get_hitbox_ataque()
        hitbox2 = self.jugador2.get_hitbox_ataque()

        rect_bloqueo2 = self.jugador2.get_rect_bloqueo()
        rect_bloqueo1 = self.jugador1.get_rect_bloqueo()

        # CORREGIDO: Usar AND en lugar de OR para verificar bloqueo
        if hitbox1 and hitbox1.colliderect(self.jugador2.get_rect()):
            if not (rect_bloqueo2 and hitbox1.colliderect(rect_bloqueo2)):
                self.procesar_golpe_mejorado(self.jugador1, self.jugador2, hitbox1)
                self.jugador1.hitbox_ataque_activa = False

        if hitbox2 and hitbox2.colliderect(self.jugador1.get_rect()):
            if not (rect_bloqueo1 and hitbox2.colliderect(rect_bloqueo1)):
                self.procesar_golpe_mejorado(self.jugador2, self.jugador1, hitbox2)
                self.jugador2.hitbox_ataque_activa = False

    def procesar_golpe_mejorado(self, atacante, defensor, hitbox):
        dano_base = atacante.get_dano_ataque()

        # Reproducir sonido según tipo de ataque
        if atacante.ataque_actual == "rapido":
            self.sistema_sonido.reproducir_sonido('golpe_suave')
        elif atacante.ataque_actual == "pesado":
            self.sistema_sonido.reproducir_sonido('golpe_fuerte')
        elif atacante.ataque_actual == "aereo":
            self.sistema_sonido.reproducir_sonido('golpe_fuerte')

        if dano_base > 25:
            self.sistema_sonido.reproducir_sonido('impacto_epico')

        if defensor.recibir_dano(
                dano_base,
                self.sistema_sonido,
                self.sistema_particulas,
                (hitbox.centerx, hitbox.centery)
        ):
            atacante.estadisticas["golpes_conectados"] += 1
            self.estadisticas_globales["total_golpes"] += 1

            nivel_impacto = self.sistema_feedback.agregar_impacto_epico(
                hitbox.centerx, hitbox.centery, dano_base, atacante.ataque_actual
            )

            if dano_base > 15:
                duracion_stun = 500 + (dano_base * 10)
                self.sistema_stun.aplicar_stun(defensor, duracion_stun, dano_base)

            contexto = {
                "porcentaje_alto": defensor.porcentaje_dano > 80,
                "ultimo_stock": (defensor.controles == "jugador1" and self.stocks_j1 == 1) or
                                (defensor.controles == "jugador2" and self.stocks_j2 == 1),
                "contraataque": False
            }

            tipo_accion = f"golpe_{atacante.ataque_actual}"
            if nivel_impacto == "epico":
                tipo_accion = "kill_epico" if defensor.vida_actual <= 0 else "golpe_fuerte"

            jugador_id = "j1" if atacante.controles == "jugador1" else "j2"
            puntos_estilo = self.sistema_estilo.registrar_accion(jugador_id, tipo_accion, contexto)
            atacante.estadisticas["puntos_estilo"] += puntos_estilo

            if atacante.combo_count > 2:
                self.sistema_combos_visual.agregar_combo(atacante, atacante.combo_count + 1, dano_base)

            atacante.habilidad_especial.cargar(10 + atacante.combo_count)

    def verificar_muertes(self):
        if self.jugador1.y > self.ALTO + 200:
            self.stocks_j1 -= 1
            self.respawn_jugador(self.jugador1)

        if self.jugador2.y > self.ALTO + 200:
            self.stocks_j2 -= 1
            self.respawn_jugador(self.jugador2)

        if self.jugador1.vida_actual <= 0:
            self.stocks_j1 -= 1
            self.respawn_jugador(self.jugador1)

        if self.jugador2.vida_actual <= 0:
            self.stocks_j2 -= 1
            self.respawn_jugador(self.jugador2)

            # En modo Supervivencia, contar enemigo derrotado
            if self.modo_actual == ModoJuego.SUPERVIVENCIA:
                self.enemigos_derrotados_oleada += 1
                self.sistema_sonido.reproducir_sonido('victoria')

    def respawn_jugador(self, jugador):
        jugador.x = 100 if jugador.controles == "jugador1" else self.ANCHO - 350
        jugador.y = self.ALTO - self.TAMANO_PERSONAJE[1]
        jugador.vida_actual = jugador.vida_maxima
        jugador.porcentaje_dano = 0
        jugador.velocidad_y = 0
        jugador.esta_stuneado = False
        jugador.invencible = True
        jugador.tiempo_invencibilidad = pygame.time.get_ticks() + 3000

        # En modo Supervivencia, si el jugador2 (enemigo) respawn, mejorar sus estadísticas
        if self.modo_actual == ModoJuego.SUPERVIVENCIA and jugador.controles == "jugador2":
            self.mejorar_enemigo_por_oleada()

    def verificar_completado_oleada(self):
        """Verifica si se completó la oleada actual en modo Supervivencia"""
        if self.enemigos_derrotados_oleada >= self.enemigos_necesarios_oleada:
            self.oleada_completada = True
            self.en_transicion_oleada = True
            self.tiempo_fin_oleada = pygame.time.get_ticks()

            # Mostrar mensaje de oleada completada
            self.sistema_feedback.mostrar_texto_flotante(
                self.ANCHO // 2, self.ALTO // 2,
                f"¡OLEADA {self.oleada_actual} COMPLETADA!", (255, 215, 0), 40
            )

            # Reproducir sonido de victoria
            self.sistema_sonido.reproducir_sonido('victoria')

            # Otorgar experiencia por completar oleada
            experiencia_oleada = 50 * self.oleada_actual
            self.sistema_progresion.ganar_experiencia_personaje(
                self.clase_jugador1, experiencia_oleada, self.jugador1.combo_count
            )

    def comenzar_nueva_oleada(self):
        """Comienza una nueva oleada en modo Supervivencia"""
        self.oleada_actual += 1
        self.enemigos_derrotados_oleada = 0
        self.enemigos_necesarios_oleada = 3 + (self.oleada_actual - 1)  # Aumenta en 1 por oleada
        self.oleada_completada = False

        # Resetear ambos jugadores
        self.respawn_jugador(self.jugador1)
        self.respawn_jugador(self.jugador2)

        # Mejorar enemigo según nueva oleada
        self.mejorar_enemigo_por_oleada()

        # Actualizar IA con nueva dificultad
        if self.ia_enemigo:
            self.ia_enemigo.dificultad = 1.0 + (self.oleada_actual - 1) * 0.2

        # Mostrar anuncio de nueva oleada
        self.sistema_feedback.mostrar_texto_flotante(
            self.ANCHO // 2, self.ALTO // 2,
            f"OLEADA {self.oleada_actual}", (255, 100, 100), 48
        )

        # Efecto visual
        self.camara.activar_temblor(5, 500)

    def verificar_fin_juego(self):
        # Modo Supervivencia: el juego termina cuando el jugador se queda sin vidas
        if self.modo_actual == ModoJuego.SUPERVIVENCIA:
            if self.stocks_j1 <= 0:
                self.estadisticas_globales["partidas_jugadas"] += 1
                return "jugador2"  # Enemigo gana
            return None

        # Modos normales
        if self.stocks_j1 <= 0 or self.stocks_j2 <= 0:
            self.estadisticas_globales["partidas_jugadas"] += 1

            if self.stocks_j1 <= 0 and self.stocks_j2 <= 0:
                self.estadisticas_globales["empates"] += 1
                return "empate"
            elif self.stocks_j1 <= 0:
                self.estadisticas_globales["victorias_j2"] += 1
                return "jugador2"
            else:
                self.estadisticas_globales["victorias_j1"] += 1
                return "jugador1"
        return None

    def dibujar(self, ventana):
        if not self.recursos_cargados or self.jugador1 is None or self.jugador2 is None:
            ventana.fill((0, 0, 0))
            fuente = pygame.font.SysFont('Arial', 48)
            texto = fuente.render("Cargando...", True, (255, 255, 255))
            ventana.blit(texto, (self.ANCHO // 2 - 100, self.ALTO // 2))
            return

        temp_surface = pygame.Surface((self.ANCHO, self.ALTO))
        if self.frames_fondo:
            temp_surface.blit(self.frames_fondo[self.indice_fondo], (0, 0))
        else:
            temp_surface.fill((20, 20, 50))

        for plataforma in self.plataformas:
            plataforma.dibujar(temp_surface)

        self.jugador1.dibujar(temp_surface)
        self.jugador2.dibujar(temp_surface)

        self.sistema_particulas.dibujar(temp_surface)

        self.camara.aplicar_a_superficie(temp_surface)

        ventana.blit(temp_surface, (0, 0))

        self.dibujar_sistemas_mejorados(ventana)

    def dibujar_sistemas_mejorados(self, ventana):
        self.sistema_feedback.dibujar(ventana)
        self.sistema_estilo.dibujar(ventana)
        self.sistema_combos_visual.dibujar(ventana)
        self.sistema_tutorial.dibujar(ventana)
        self.dibujar_ui_mejorada(ventana)
        self.dibujar_anuncios_clutch(ventana)

        # Dibujar información de oleada (modo Supervivencia)
        if self.modo_actual == ModoJuego.SUPERVIVENCIA:
            self.dibujar_info_oleada(ventana)

    def dibujar_ui_mejorada(self, ventana):
        self.dibujar_barra_vida_mejorada(ventana, 50, 30, self.jugador1, "JUGADOR 1", self.stocks_j1)
        self.dibujar_barra_vida_mejorada(ventana, self.ANCHO - 450, 30, self.jugador2, "JUGADOR 2", self.stocks_j2)
        self.dibujar_barra_momentum(ventana)
        self.dibujar_puntos_estilo(ventana)

        # Mostrar combo actual si está activo
        if self.jugador1.combo_count > 0:
            self.dibujar_combo_actual(ventana, self.jugador1, 50, 100)
        if self.jugador2.combo_count > 0:
            self.dibujar_combo_actual(ventana, self.jugador2, self.ANCHO - 250, 100)

    def dibujar_info_oleada(self, ventana):
        """Dibuja la información de la oleada actual en modo Supervivencia"""
        fuente = pygame.font.SysFont('Arial', 32, bold=True)
        fuente_pequena = pygame.font.SysFont('Arial', 24)

        # Fondo para la información
        pygame.draw.rect(ventana, (0, 0, 0, 180), (self.ANCHO // 2 - 150, 10, 300, 80), border_radius=10)
        pygame.draw.rect(ventana, (255, 255, 255), (self.ANCHO // 2 - 150, 10, 300, 80), 2, border_radius=10)

        # Texto de oleada
        texto_oleada = fuente.render(f"OLEADA {self.oleada_actual}", True, (255, 215, 0))
        ventana.blit(texto_oleada, (self.ANCHO // 2 - texto_oleada.get_width() // 2, 20))

        # Progreso de la oleada
        progreso = self.enemigos_derrotados_oleada / self.enemigos_necesarios_oleada
        texto_progreso = fuente_pequena.render(
            f"Enemigos: {self.enemigos_derrotados_oleada}/{self.enemigos_necesarios_oleada}",
            True, (200, 200, 200)
        )
        ventana.blit(texto_progreso, (self.ANCHO // 2 - texto_progreso.get_width() // 2, 55))

        # Barra de progreso
        barra_ancho = 250
        barra_alto = 10
        x = self.ANCHO // 2 - barra_ancho // 2
        y = 85

        pygame.draw.rect(ventana, (50, 50, 50), (x, y, barra_ancho, barra_alto))
        pygame.draw.rect(ventana, (100, 255, 100), (x, y, int(barra_ancho * progreso), barra_alto))
        pygame.draw.rect(ventana, (255, 255, 255), (x, y, barra_ancho, barra_alto), 1)

        # Mostrar "TRANSICIÓN" si estamos entre oleadas
        if self.en_transicion_oleada:
            tiempo_restante = max(0, self.tiempo_entre_oleadas - (pygame.time.get_ticks() - self.tiempo_fin_oleada))
            segundos = tiempo_restante // 1000 + 1

            fuente_transicion = pygame.font.SysFont('Arial', 36, bold=True)
            texto_transicion = fuente_transicion.render(
                f"PREPÁRATE... {segundos}", True, (255, 100, 100)
            )

            # Fondo para el texto
            fondo_ancho = texto_transicion.get_width() + 40
            fondo_alto = texto_transicion.get_height() + 20
            pygame.draw.rect(ventana, (0, 0, 0, 200),
                             (self.ANCHO // 2 - fondo_ancho // 2, self.ALTO // 2 - fondo_alto // 2,
                              fondo_ancho, fondo_alto), border_radius=15)
            pygame.draw.rect(ventana, (255, 255, 255),
                             (self.ANCHO // 2 - fondo_ancho // 2, self.ALTO // 2 - fondo_alto // 2,
                              fondo_ancho, fondo_alto), 3, border_radius=15)

            ventana.blit(texto_transicion,
                         (self.ANCHO // 2 - texto_transicion.get_width() // 2,
                          self.ALTO // 2 - texto_transicion.get_height() // 2))

    def dibujar_combo_actual(self, ventana, jugador, x, y):
        """Dibuja el combo actual del jugador"""
        fuente = pygame.font.SysFont('Arial', 28, bold=True)

        # Color diferente para modo combos infinitos
        if jugador.modo_combos_infinitos:
            color = (255, 215, 0)  # Dorado para combos infinitos
            texto_combo = f"COMBO INFINITO: x{jugador.combo_count + 1}"
        else:
            color = (255, 255, 0)  # Amarillo normal
            texto_combo = f"COMBO: x{jugador.combo_count + 1}"

        texto = fuente.render(texto_combo, True, color)

        # Fondo semitransparente
        fondo = pygame.Surface((texto.get_width() + 20, texto.get_height() + 10), pygame.SRCALPHA)
        fondo.fill((0, 0, 0, 150))
        ventana.blit(fondo, (x - 10, y - 5))

        ventana.blit(texto, (x, y))

        # Barra de tiempo de combo (solo en modo normal)
        if not jugador.modo_combos_infinitos and jugador.combo_timer > 0:
            barra_ancho = 150
            barra_alto = 8
            tiempo_restante = jugador.combo_timer / jugador.combo_max_time

            pygame.draw.rect(ventana, (50, 50, 50), (x, y + 35, barra_ancho, barra_alto))
            pygame.draw.rect(ventana, (0, 255, 0), (x, y + 35, int(barra_ancho * tiempo_restante), barra_alto))
            pygame.draw.rect(ventana, (255, 255, 255), (x, y + 35, barra_ancho, barra_alto), 1)

    def dibujar_barra_vida_mejorada(self, ventana, x, y, jugador, nombre, stocks):
        ancho, alto = 400, 30

        pygame.draw.rect(ventana, (50, 50, 50), (x, y, ancho, alto), border_radius=5)

        porcentaje_vida = jugador.vida_actual / jugador.vida_maxima
        ancho_vida = int(ancho * porcentaje_vida)

        if jugador.porcentaje_dano > 100:
            color_vida = (255, 50, 50)
        elif jugador.porcentaje_dano > 50:
            color_vida = (255, 255, 50)
        else:
            color_vida = (50, 255, 50)

        pygame.draw.rect(ventana, color_vida, (x, y, ancho_vida, alto), border_radius=5)
        pygame.draw.rect(ventana, (255, 255, 255), (x, y, ancho, alto), 2, border_radius=5)

        fuente = pygame.font.SysFont('Arial', 20, bold=True)
        texto = fuente.render(f"{nombre} - {jugador.porcentaje_dano:.0f}%", True, (255, 255, 255))
        ventana.blit(texto, (x + 10, y + 5))

        for i in range(stocks):
            pygame.draw.circle(ventana, jugador.config_clase["color"],
                               (x + 20 + i * 25, y - 15), 8)

    def dibujar_barra_momentum(self, ventana):
        ancho, alto = 150, 15
        x1, y1 = 50, self.ALTO - 40
        x2, y2 = self.ANCHO - 200, self.ALTO - 40

        pygame.draw.rect(ventana, (50, 50, 50), (x1, y1, ancho, alto))
        pygame.draw.rect(ventana, (100, 200, 255),
                         (x1, y1, ancho * (self.sistema_momentum.momentum_j1 / 100), alto))

        pygame.draw.rect(ventana, (50, 50, 50), (x2, y2, ancho, alto))
        pygame.draw.rect(ventana, (255, 100, 100),
                         (x2, y2, ancho * (self.sistema_momentum.momentum_j2 / 100), alto))

    def dibujar_puntos_estilo(self, ventana):
        fuente = pygame.font.SysFont('Arial', 24, bold=True)

        texto_j1 = fuente.render(f"Estilo: {self.sistema_estilo.puntuacion_j1}", True, (100, 200, 255))
        texto_j2 = fuente.render(f"Estilo: {self.sistema_estilo.puntuacion_j2}", True, (255, 100, 100))

        ventana.blit(texto_j1, (50, 70))
        ventana.blit(texto_j2, (self.ANCHO - 200, 70))

    def dibujar_anuncios_clutch(self, ventana):
        fuente = pygame.font.SysFont('Arial', 28, bold=True)

        for anuncio in self.mecanicas_clutch.anuncios_clutch:
            tiempo_transcurrido = pygame.time.get_ticks() - anuncio["tiempo"]
            progreso = tiempo_transcurrido / anuncio["duracion"]
            alpha = int(255 * (1 - progreso))

            color = (100, 200, 255) if anuncio["jugador"] == "jugador1" else (255, 100, 100)
            texto = fuente.render(anuncio["mensaje"], True, color)
            texto.set_alpha(alpha)

            rect = texto.get_rect(center=(self.ANCHO // 2, anuncio["y"]))
            ventana.blit(texto, rect)


# =============================================================================
# CLASES AUXILIARES
# =============================================================================

class Plataforma:
    def __init__(self, x, y, ancho, alto, tipo="estatica", color=None):
        self.rect = pygame.Rect(x, y, ancho, alto)
        self.tipo = tipo
        self.color = color or (150, 75, 0)
        self.borde_color = (100, 50, 0)

    def dibujar(self, ventana):
        pygame.draw.rect(ventana, self.color, self.rect)
        pygame.draw.rect(ventana, self.borde_color, self.rect, 3)


# =============================================================================
# FUNCIONES AUXILIARES
# =============================================================================

def dibujar_game_over(ventana, ANCHO, ALTO, ganador, oleada_final=None):
    overlay = pygame.Surface((ANCHO, ALTO))
    overlay.set_alpha(200)
    overlay.fill((0, 0, 0))
    ventana.blit(overlay, (0, 0))

    fuente_titulo = pygame.font.SysFont('Arial', 80, bold=True)
    fuente_texto = pygame.font.SysFont('Arial', 32)
    fuente_oleada = pygame.font.SysFont('Arial', 48, bold=True)

    if ganador == "jugador1":
        texto = "¡VICTORIA!"
        color = (100, 255, 100)
    elif ganador == "jugador2":
        texto = "¡DERROTA!"
        color = (255, 100, 100)
    else:
        texto = "¡EMPATE!"
        color = (255, 255, 255)

    titulo = fuente_titulo.render(texto, True, color)
    titulo_rect = titulo.get_rect(center=(ANCHO // 2, ALTO // 2 - 120))
    ventana.blit(titulo, titulo_rect)

    # Mostrar oleada alcanzada en modo Supervivencia
    if oleada_final is not None:
        texto_oleada = fuente_oleada.render(f"Oleada alcanzada: {oleada_final}", True, (255, 215, 0))
        oleada_rect = texto_oleada.get_rect(center=(ANCHO // 2, ALTO // 2 - 40))
        ventana.blit(texto_oleada, oleada_rect)

    reiniciar = fuente_texto.render("Presiona R para otra ronda", True, (0, 255, 0))
    reiniciar_rect = reiniciar.get_rect(center=(ANCHO // 2, ALTO // 2 + 50))
    ventana.blit(reiniciar, reiniciar_rect)

    menu = fuente_texto.render("Presiona M para ir al menú", True, (100, 200, 255))
    menu_rect = menu.get_rect(center=(ANCHO // 2, ALTO // 2 + 100))
    ventana.blit(menu, menu_rect)


# =============================================================================
# FUNCIÓN PRINCIPAL - CORREGIDA CON SISTEMA DE CONTROLES CONFIGURABLES
# =============================================================================

def main():
    print("\n========== INICIANDO STICK MAN ARENA - EDICIÓN ÉPICA ==========")
    print("Mejoras implementadas:")
    print("1. Modo Supervivencia por oleadas")
    print("2. Combos infinitos REALMENTE infinitos")
    print("3. Ataques pesados corregidos para que conecten")
    print("4. Sistema de controles configurable funcionando")

    sistema_config = SistemaConfiguracion()
    ANCHO, ALTO = ventana.get_size()

    menu_principal = MenuPrincipal(ANCHO, ALTO)
    menu_seleccion_modo = MenuSeleccionModo(ANCHO, ALTO)
    menu_seleccion_personaje = MenuSeleccionPersonaje(ANCHO, ALTO)
    menu_opciones = MenuOpciones(ANCHO, ALTO, sistema_config)
    juego = Juego(ANCHO, ALTO)

    estado_actual = MENU
    ganador = None
    modo_seleccionado = None
    oleada_final = None  # Para mostrar en game over

    ejecutando = True
    while ejecutando:
        for evento in pygame.event.get():
            if evento.type == pygame.QUIT:
                juego.guardar_estadisticas()
                sistema_config.guardar_configuracion()
                ejecutando = False

            if estado_actual == MENU:
                resultado = menu_principal.manejar_evento(evento, juego.sistema_sonido)
                if resultado == "jugar":
                    estado_actual = SELECCION_MODO
                elif resultado == "opciones":
                    estado_actual = OPCIONES
                elif resultado == "salir":
                    ejecutando = False

            elif estado_actual == OPCIONES:
                resultado = menu_opciones.manejar_evento(evento, juego.sistema_sonido)
                if resultado == "menu":
                    estado_actual = MENU
                elif resultado == "aplicar":
                    juego.aplicar_configuracion_completa()
                    sistema_config.guardar_configuracion()
                    estado_actual = MENU

            elif estado_actual == SELECCION_MODO:
                resultado = menu_seleccion_modo.manejar_evento(evento, juego.sistema_sonido)
                if resultado in [ModoJuego.CLASICO, ModoJuego.SUPERVIVENCIA, ModoJuego.COMBOS_INFINITOS]:
                    modo_seleccionado = resultado
                    estado_actual = SELECCION_PERSONAJE
                elif resultado == "menu":
                    estado_actual = MENU
                elif resultado == "salir":
                    ejecutando = False

            elif estado_actual == SELECCION_PERSONAJE:
                resultado = menu_seleccion_personaje.manejar_evento(evento, juego.sistema_sonido)
                if resultado == "empezar":
                    juego.configurar_modo(modo_seleccionado)
                    juego.configurar_personajes(
                        menu_seleccion_personaje.personaje_seleccionado_j1,
                        menu_seleccion_personaje.personaje_seleccionado_j2
                    )
                    juego.cargar_recursos_si_es_necesario()
                    estado_actual = JUGANDO
                elif resultado == "menu":
                    estado_actual = MENU
                elif resultado == "salir":
                    ejecutando = False

            elif estado_actual == JUGANDO:
                if evento.type == pygame.KEYDOWN:
                    if evento.key == pygame.K_ESCAPE:
                        estado_actual = MENU
                        continue

                    # Obtener controles configurados
                    controles_j1 = sistema_config.config["controles"]["jugador1"]
                    controles_j2 = sistema_config.config["controles"]["jugador2"]

                    # CONTROLES JUGADOR 1 (usando configuración)
                    if evento.key == controles_j1["ataque_rapido"]:
                        if juego.jugador1 is not None:
                            juego.jugador1.ataque_rapido(juego.sistema_sonido, juego.sistema_particulas)
                    elif evento.key == controles_j1["ataque_pesado"]:
                        if juego.jugador1 is not None:
                            juego.jugador1.ataque_pesado(juego.sistema_sonido, juego.sistema_particulas)
                    elif evento.key == controles_j1["arriba"]:
                        if juego.jugador1 is not None:
                            juego.jugador1.saltar(juego.sistema_sonido)
                    elif evento.key == controles_j1["habilidad"]:
                        if juego.jugador1 is not None:
                            juego.jugador1.activar_habilidad(juego.sistema_particulas, juego.sistema_sonido)
                    elif evento.key == controles_j1["bloqueo"]:
                        if juego.jugador1 is not None:
                            juego.jugador1.bloquear()

                    # CONTROLES JUGADOR 2 (usando configuración)
                    elif evento.key == controles_j2["ataque_rapido"]:
                        if juego.jugador2 is not None:
                            juego.jugador2.ataque_rapido(juego.sistema_sonido, juego.sistema_particulas)
                    elif evento.key == controles_j2["ataque_pesado"]:
                        if juego.jugador2 is not None:
                            juego.jugador2.ataque_pesado(juego.sistema_sonido, juego.sistema_particulas)
                    elif evento.key == controles_j2["arriba"]:
                        if juego.jugador2 is not None:
                            juego.jugador2.saltar(juego.sistema_sonido)
                    elif evento.key == controles_j2["habilidad"]:
                        if juego.jugador2 is not None:
                            juego.jugador2.activar_habilidad(juego.sistema_particulas, juego.sistema_sonido)
                    elif evento.key == controles_j2["bloqueo"]:
                        if juego.jugador2 is not None:
                            juego.jugador2.bloquear()

                if evento.type == pygame.KEYUP:
                    controles_j1 = sistema_config.config["controles"]["jugador1"]
                    controles_j2 = sistema_config.config["controles"]["jugador2"]

                    if evento.key == controles_j1["bloqueo"]:
                        if juego.jugador1 is not None:
                            juego.jugador1.dejar_bloquear()
                    elif evento.key == controles_j2["bloqueo"]:
                        if juego.jugador2 is not None:
                            juego.jugador2.dejar_bloquear()

            elif estado_actual == GAME_OVER:
                if evento.type == pygame.KEYDOWN:
                    if evento.key == pygame.K_r:
                        juego.resetear_juego()
                        estado_actual = JUGANDO
                        ganador = None
                        oleada_final = None
                    elif evento.key == pygame.K_m:
                        estado_actual = MENU
                        ganador = None
                        oleada_final = None
                    elif evento.key == pygame.K_ESCAPE:
                        ejecutando = False

        # Actualizar según estado
        if estado_actual == MENU:
            menu_principal.dibujar(ventana)
        elif estado_actual == OPCIONES:
            menu_opciones.dibujar(ventana)
        elif estado_actual == SELECCION_MODO:
            menu_seleccion_modo.dibujar(ventana)
        elif estado_actual == SELECCION_PERSONAJE:
            menu_seleccion_personaje.dibujar(ventana)
        elif estado_actual == JUGANDO:
            if juego.recursos_cargados:
                juego.actualizar()
                juego.dibujar(ventana)

            ganador = juego.verificar_fin_juego()
            if ganador:
                juego.sistema_sonido.reproducir_sonido('victoria')
                oleada_final = juego.oleada_actual if juego.modo_actual == ModoJuego.SUPERVIVENCIA else None
                estado_actual = GAME_OVER
        elif estado_actual == GAME_OVER:
            if juego.recursos_cargados:
                juego.dibujar(ventana)
                dibujar_game_over(ventana, ANCHO, ALTO, ganador, oleada_final)

        pygame.display.update()

        # Control de FPS con configuración
        limite_fps = sistema_config.config["graficos"]["limite_fps"]
        if juego.camara.slow_motion:
            clock.tick(limite_fps * juego.camara.factor_slow_motion)
        else:
            clock.tick(limite_fps)

    pygame.quit()
    sys.exit()


if __name__ == "__main__":
    main()
