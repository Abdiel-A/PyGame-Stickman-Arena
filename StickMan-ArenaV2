import pygame
import sys
import os
import random
import math
import json
from enum import Enum
import collections  # Para optimizar part√≠culas
from datetime import datetime

# =============================================================================
# CONFIGURACI√ìN INICIAL
# =============================================================================

# Inicializar Pygame
pygame.init()

# Configuraci√≥n de pantalla
try:
    # Intentar pantalla completa
    info = pygame.display.Info()
    ANCHO, ALTO = info.current_w, info.current_h
    ventana = pygame.display.set_mode((ANCHO, ALTO), pygame.FULLSCREEN)
    print(f"‚úÖ Pantalla completa: {ANCHO}x{ALTO}")
except:
    # Fallback a ventana
    ANCHO, ALTO = 1280, 720
    ventana = pygame.display.set_mode((ANCHO, ALTO))
    print(f"‚ö†Ô∏è  Modo ventana: {ANCHO}x{ALTO}")

pygame.display.set_caption("Stick Man Arena - Edici√≥n √âpica")
clock = pygame.time.Clock()
FPS = 60

# Inicializar sonido
try:
    pygame.mixer.init(frequency=22050, size=-16, channels=2, buffer=512)
    sonido_disponible = True
    print("‚úÖ Sonido inicializado")
except:
    sonido_disponible = False
    print("‚ö†Ô∏è  Sonido no disponible")


# =============================================================================
# ENUMERACIONES Y CONFIGURACIONES
# =============================================================================

# Estados del juego
class EstadoJuego(Enum):
    MENU = "menu"
    SELECCION_MODO = "seleccion_modo"
    SELECCION_PERSONAJE = "seleccion_personaje"
    JUGANDO = "jugando"
    GAME_OVER = "game_over"
    OPCIONES = "opciones"
    CONTROLES = "controles"


# Modos de juego
class ModoJuego(Enum):
    CLASICO = "clasico"
    SUPERVIVENCIA = "supervivencia"
    COMBOS_INFINITOS = "combos_infinitos"


# Clases de personaje con mejoras visuales
CLASES_PERSONAJE = {
    "guerrero": {
        "nombre": "GUERRERO",
        "vida": 120,
        "velocidad": 8,
        "dano_base": 12,
        "color": (65, 105, 225),  # Azul real
        "color_claro": (135, 206, 250),  # Azul cielo
        "color_oscuro": (25, 25, 112),  # Azul medianoche
        "habilidad": "golpe_cargado",
        "descripcion": "Equilibrado en ataque y defensa",
        "icono": "‚öîÔ∏è",
        "estadisticas": ["Fuerza: 8/10", "Agilidad: 6/10", "Defensa: 7/10"]
    },
    "asesino": {
        "nombre": "ASESINO",
        "vida": 85,
        "velocidad": 12,
        "dano_base": 16,
        "color": (220, 20, 60),  # Rojo carmes√≠
        "color_claro": (255, 105, 97),  # Rojo claro
        "color_oscuro": (139, 0, 0),  # Rojo oscuro
        "habilidad": "dash_ataque",
        "descripcion": "Veloz y mortal, pero fr√°gil",
        "icono": "üó°Ô∏è",
        "estadisticas": ["Fuerza: 6/10", "Agilidad: 10/10", "Defensa: 4/10"]
    },
    "tanque": {
        "nombre": "TANQUE",
        "vida": 160,
        "velocidad": 5,
        "dano_base": 9,
        "color": (34, 139, 34),  # Verde bosque
        "color_claro": (144, 238, 144),  # Verde claro
        "color_oscuro": (0, 100, 0),  # Verde oscuro
        "habilidad": "bloqueo_fuerte",
        "descripcion": "Resistente pero lento",
        "icono": "üõ°Ô∏è",
        "estadisticas": ["Fuerza: 7/10", "Agilidad: 3/10", "Defensa: 10/10"]
    },
    "mago": {
        "nombre": "MAGO",
        "vida": 95,
        "velocidad": 7,
        "dano_base": 14,
        "color": (138, 43, 226),  # P√∫rpura
        "color_claro": (216, 191, 216),  # P√∫rpura claro
        "color_oscuro": (75, 0, 130),  # √çndigo
        "habilidad": "rayo_energia",
        "descripcion": "Ataques m√°gicos a distancia",
        "icono": "üîÆ",
        "estadisticas": ["Fuerza: 5/10", "Agilidad: 7/10", "Defensa: 6/10"]
    }
}

# Configuraci√≥n de modos de juego
CONFIG_MODOS = {
    ModoJuego.CLASICO: {
        "nombre": "MODO CL√ÅSICO",
        "descripcion": "Combate tradicional 1vs1\n‚Ä¢ 3 vidas por jugador\n‚Ä¢ Sin habilidades especiales\n‚Ä¢ Ideal para aprender",
        "color": (100, 200, 255),
        "icono": "ü•ä",
        "vidas": 3,
        "tiempo": 300,  # 5 minutos
        "habilidades": False
    },
    ModoJuego.SUPERVIVENCIA: {
        "nombre": "SUPERVIVENCIA",
        "descripcion": "Sobrevive a oleadas de enemigos\n‚Ä¢ Enemigos mejoran cada oleada\n‚Ä¢ Poderes especiales\n‚Ä¢ Recompensas por progreso",
        "color": (255, 100, 100),
        "icono": "üíÄ",
        "vidas": 1,
        "oleadas": True,
        "habilidades": True
    },
    ModoJuego.COMBOS_INFINITOS: {
        "nombre": "COMBOS INFINITOS",
        "descripcion": "Combos que nunca terminan\n‚Ä¢ Da√±o aumenta con cada golpe\n‚Ä¢ Sin l√≠mite de combo\n‚Ä¢ Ideal para expertos",
        "color": (255, 215, 0),
        "icono": "‚ôæÔ∏è",
        "vidas": 3,
        "combo_infinito": True,
        "tiempo": 180  # 3 minutos
    }
}


# =============================================================================
# SISTEMA DE PROGRESI√ìN
# =============================================================================

class SistemaProgresion:
    def __init__(self):
        self.archivo_progresion = "progresion.json"
        self.progresion = self.cargar_progresion()

    def cargar_progresion(self):
        try:
            with open(self.archivo_progresion, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            # Crear progresi√≥n por defecto
            progresion_default = {
                "version": "2.0",
                "fecha_creacion": datetime.now().isoformat(),
                "nivel_global": 1,
                "exp_global": 0,
                "partidas_jugadas": 0,
                "victorias": 0,
                "derrotas": 0,
                "empates": 0,
                "mejor_combo": 0,
                "personajes": {},
                "logros": [],
                "configuracion": {
                    "volumen_musica": 0.7,
                    "volumen_efectos": 0.8,
                    "pantalla_completa": True,
                    "mostrar_fps": True
                }
            }

            # Inicializar progresi√≥n de personajes
            for clase_id, clase_info in CLASES_PERSONAJE.items():
                progresion_default["personajes"][clase_id] = {
                    "nivel": 1,
                    "exp": 0,
                    "partidas_jugadas": 0,
                    "victorias": 0,
                    "habilidades_desbloqueadas": ["base"],
                    "mejor_combo": 0,
                    "dano_total": 0,
                    "golpes_conectados": 0
                }

            self.guardar_progresion(progresion_default)
            return progresion_default

    def guardar_progresion(self, progresion=None):
        if progresion is None:
            progresion = self.progresion

        try:
            with open(self.archivo_progresion, 'w') as f:
                json.dump(progresion, f, indent=4)
            return True
        except Exception as e:
            print(f"‚ùå Error guardando progresi√≥n: {e}")
            return False

    def ganar_experiencia(self, clase, exp_ganada, combo_max=0, victoria=False):
        if clase not in self.progresion["personajes"]:
            self.progresion["personajes"][clase] = {
                "nivel": 1,
                "exp": 0,
                "partidas_jugadas": 0,
                "victorias": 0,
                "habilidades_desbloqueadas": ["base"],
                "mejor_combo": 0,
                "dano_total": 0,
                "golpes_conectados": 0
            }

        personaje = self.progresion["personajes"][clase]
        personaje["exp"] += exp_ganada
        personaje["partidas_jugadas"] += 1

        if victoria:
            personaje["victorias"] += 1
            self.progresion["victorias"] += 1

        if combo_max > personaje["mejor_combo"]:
            personaje["mejor_combo"] = combo_max

        if combo_max > self.progresion["mejor_combo"]:
            self.progresion["mejor_combo"] = combo_max

        # Subir de nivel si se alcanza la experiencia necesaria
        exp_necesaria = 100 * (personaje["nivel"] ** 1.5)
        if personaje["exp"] >= exp_necesaria:
            return self.subir_nivel(clase)

        self.guardar_progresion()
        return False

    def subir_nivel(self, clase):
        personaje = self.progresion["personajes"][clase]
        personaje["nivel"] += 1
        personaje["exp"] = 0

        # Desbloquear habilidades seg√∫n nivel
        habilidades_por_nivel = {
            2: ["ataque_cargado"],
            3: ["defensa_mejorada"],
            4: ["contraataque"],
            5: ["velocidad_mejorada"],
            6: ["vida_extra"],
            7: ["dano_critico"],
            8: ["regeneracion"],
            9: ["invencibilidad_temporal"],
            10: ["super_ataque"]
        }

        nivel_actual = personaje["nivel"]
        if nivel_actual in habilidades_por_nivel:
            for habilidad in habilidades_por_nivel[nivel_actual]:
                if habilidad not in personaje["habilidades_desbloqueadas"]:
                    personaje["habilidades_desbloqueadas"].append(habilidad)

        # Desbloquear logro
        logro_id = f"nivel_{nivel_actual}_{clase}"
        if logro_id not in self.progresion["logros"]:
            self.progresion["logros"].append(logro_id)

        self.guardar_progresion()
        return True


# =============================================================================
# SISTEMA DE SONIDO MEJORADO
# =============================================================================

class SistemaSonido:
    def __init__(self):
        self.sonidos = {}
        self.musica = None
        self.volumen_musica = 0.7
        self.volumen_efectos = 0.8
        self.activado = True
        self.cargar_sonidos()

    def cargar_sonidos(self):
        """Carga todos los sonidos del juego"""
        try:
            # Generar sonidos proceduralmente si no hay archivos
            self.crear_sonidos_basicos()
            print("‚úÖ Sonidos cargados correctamente")
        except Exception as e:
            print(f"‚ö†Ô∏è  Error cargando sonidos: {e}")
            self.crear_sonidos_placeholder()

    def crear_sonidos_basicos(self):
        """Crea sonidos b√°sicos proceduralmente"""
        self.sonidos = {
            'menu_select': self.crear_sonido_simple(800, 0.1),
            'menu_navigate': self.crear_sonido_simple(600, 0.05),
            'ataque_rapido': self.crear_sonido_simple(300, 0.1),
            'ataque_pesado': self.crear_sonido_simple(150, 0.2),
            'ataque_aereo': self.crear_sonido_simple(400, 0.15),
            'salto': self.crear_sonido_simple(500, 0.08),
            'impacto': self.crear_sonido_simple(200, 0.25),
            'impacto_fuerte': self.crear_sonido_simple(100, 0.3),
            'habilidad': self.crear_sonido_simple(1000, 0.2),
            'victoria': self.crear_sonido_simple(600, 0.5),
            'derrota': self.crear_sonido_simple(200, 0.4),
            'powerup': self.crear_sonido_simple(1200, 0.15),
            'combo': self.crear_sonido_simple(1000, 0.1),
            'nivel': self.crear_sonido_simple(800, 0.3),
            'error': self.crear_sonido_simple(100, 0.1)
        }

        # Ajustar vol√∫menes espec√≠ficos
        for nombre, sonido in self.sonidos.items():
            sonido.set_volume(self.volumen_efectos)

    def crear_sonido_simple(self, frecuencia, duracion):
        """Crea un sonido simple procedural"""
        sample_rate = 22050
        n_samples = int(duracion * sample_rate)
        samples = []

        for i in range(n_samples):
            t = i / sample_rate
            # Onda cuadrada
            sample = 0.5 if math.sin(2 * math.pi * frecuencia * t) > 0 else -0.5
            samples.append(sample)

        # Convertir a bytes
        import array
        arr = array.array('h', [int(s * 32767) for s in samples])
        return pygame.mixer.Sound(buffer=arr.tobytes())

    def crear_sonidos_placeholder(self):
        """Crea sonidos de placeholder"""
        self.sonidos = {
            nombre: pygame.mixer.Sound(buffer=bytes([0]))
            for nombre in ['menu_select', 'ataque_rapido', 'ataque_pesado',
                           'salto', 'impacto', 'victoria', 'error']
        }

    def reproducir(self, nombre):
        """Reproduce un sonido"""
        if self.activado and nombre in self.sonidos:
            try:
                self.sonidos[nombre].play()
            except:
                pass

    def alternar(self):
        """Alterna el estado del sonido"""
        self.activado = not self.activado
        return self.activado

    def ajustar_volumen_musica(self, volumen):
        """Ajusta el volumen de la m√∫sica"""
        self.volumen_musica = max(0.0, min(1.0, volumen))
        if self.musica:
            self.musica.set_volume(self.volumen_musica)

    def ajustar_volumen_efectos(self, volumen):
        """Ajusta el volumen de los efectos"""
        self.volumen_efectos = max(0.0, min(1.0, volumen))
        for sonido in self.sonidos.values():
            sonido.set_volume(self.volumen_efectos)


# =============================================================================
# SISTEMA DE PART√çCULAS MEJORADO
# =============================================================================

class SistemaParticulas:
    def __init__(self):
        self.particulas = []
        self.max_particulas = 1000

    def agregar_explosion(self, x, y, color, tama√±o="normal"):
        """Agrega una explosi√≥n de part√≠culas"""
        if tama√±o == "peque√±o":
            cantidad = 15
            velocidad = 3
        elif tama√±o == "grande":
            cantidad = 40
            velocidad = 6
        else:
            cantidad = 25
            velocidad = 4

        for _ in range(cantidad):
            angulo = random.uniform(0, math.pi * 2)
            vel = random.uniform(velocidad * 0.5, velocidad * 1.5)
            vel_x = math.cos(angulo) * vel
            vel_y = math.sin(angulo) * vel

            # Variar el color
            variacion = random.randint(-30, 30)
            r = max(0, min(255, color[0] + variacion))
            g = max(0, min(255, color[1] + variacion))
            b = max(0, min(255, color[2] + variacion))
            color_variado = (r, g, b)

            self.particulas.append({
                'x': x,
                'y': y,
                'vel_x': vel_x,
                'vel_y': vel_y,
                'color': color_variado,
                'vida': random.randint(30, 60),
                'tama√±o': random.randint(2, 5),
                'gravedad': 0.1
            })

    def agregar_chispa(self, x, y, color, direccion):
        """Agrega chispas en una direcci√≥n espec√≠fica"""
        for _ in range(8):
            angulo = direccion + random.uniform(-0.5, 0.5)
            vel = random.uniform(2, 5)
            vel_x = math.cos(angulo) * vel
            vel_y = math.sin(angulo) * vel

            self.particulas.append({
                'x': x,
                'y': y,
                'vel_x': vel_x,
                'vel_y': vel_y,
                'color': color,
                'vida': random.randint(20, 40),
                'tama√±o': random.randint(1, 3),
                'gravedad': 0.05
            })

    def agregar_aura(self, x, y, color):
        """Agrega un efecto de aura alrededor de un punto"""
        for _ in range(10):
            angulo = random.uniform(0, math.pi * 2)
            distancia = random.uniform(20, 50)
            px = x + math.cos(angulo) * distancia
            py = y + math.sin(angulo) * distancia

            self.particulas.append({
                'x': px,
                'y': py,
                'vel_x': 0,
                'vel_y': -random.uniform(0.5, 1.5),
                'color': color,
                'vida': random.randint(40, 80),
                'tama√±o': random.randint(3, 6),
                'gravedad': -0.02
            })

    def actualizar(self):
        """Actualiza todas las part√≠culas"""
        i = 0
        while i < len(self.particulas):
            p = self.particulas[i]

            # Aplicar movimiento
            p['x'] += p['vel_x']
            p['y'] += p['vel_y']

            # Aplicar gravedad
            p['vel_y'] += p.get('gravedad', 0.1)

            # Reducir vida
            p['vida'] -= 1

            # Eliminar si la vida termin√≥
            if p['vida'] <= 0:
                self.particulas.pop(i)
            else:
                i += 1

    def dibujar(self, superficie):
        """Dibuja todas las part√≠culas"""
        for p in self.particulas:
            # Calcular alpha basado en vida
            alpha = int(255 * (p['vida'] / 60))

            # Crear superficie para la part√≠cula con alpha
            surf_particula = pygame.Surface((p['tama√±o'] * 2, p['tama√±o'] * 2), pygame.SRCALPHA)

            # Dibujar part√≠cula
            color_con_alpha = (*p['color'], alpha)
            pygame.draw.circle(surf_particula, color_con_alpha,
                               (p['tama√±o'], p['tama√±o']), p['tama√±o'])

            # Dibujar en la superficie principal
            superficie.blit(surf_particula,
                            (int(p['x'] - p['tama√±o']), int(p['y'] - p['tama√±o'])))


# =============================================================================
# GENERADOR DE SPRITES DIN√ÅMICOS
# =============================================================================

class GeneradorSprites:
    @staticmethod
    def crear_sprite_personaje(clase, estado, frame, tama√±o=(200, 200)):
        """Crea un sprite din√°mico para un personaje"""
        surf = pygame.Surface(tama√±o, pygame.SRCALPHA)
        info_clase = CLASES_PERSONAJE[clase]

        # Colores del personaje
        color_principal = info_clase["color"]
        color_claro = info_clase["color_claro"]
        color_oscuro = info_clase["color_oscuro"]

        # Posiciones base
        centro_x = tama√±o[0] // 2
        cabeza_y = tama√±o[1] // 3

        # Animaci√≥n basada en estado y frame
        offset_animacion = math.sin(frame * 0.5) * 5 if estado == "idle" else 0

        if estado == "idle":
            # Cabeza
            pygame.draw.circle(surf, color_principal,
                               (centro_x, cabeza_y + offset_animacion), 30)

            # Cuerpo
            cuerpo_rect = pygame.Rect(centro_x - 25, cabeza_y + 30 + offset_animacion, 50, 80)
            pygame.draw.rect(surf, color_principal, cuerpo_rect, border_radius=10)

            # Brazos
            angulo_brazos = math.sin(frame * 0.3) * 0.3
            GeneradorSprites.dibujar_brazo(surf, centro_x, cabeza_y + 40,
                                           angulo_brazos, color_principal, lado="izquierdo")
            GeneradorSprites.dibujar_brazo(surf, centro_x, cabeza_y + 40,
                                           -angulo_brazos, color_principal, lado="derecho")

            # Piernas
            angulo_piernas = math.sin(frame * 0.3 + 0.5) * 0.2
            GeneradorSprites.dibujar_pierna(surf, centro_x, cabeza_y + 100,
                                            angulo_piernas, color_principal, lado="izquierdo")
            GeneradorSprites.dibujar_pierna(surf, centro_x, cabeza_y + 100,
                                            -angulo_piernas, color_principal, lado="derecho")

        elif estado == "run":
            # Cabeza
            offset_x = math.sin(frame * 0.8) * 15
            pygame.draw.circle(surf, color_principal,
                               (centro_x + offset_x, cabeza_y), 30)

            # Cuerpo inclinado
            cuerpo_rect = pygame.Rect(centro_x + offset_x - 25, cabeza_y + 30, 50, 80)
            pygame.draw.rect(surf, color_principal, cuerpo_rect, border_radius=10)

            # Brazos corridos
            angulo_brazos = math.sin(frame * 1.5) * 1.0
            GeneradorSprites.dibujar_brazo(surf, centro_x + offset_x, cabeza_y + 40,
                                           angulo_brazos, color_principal, lado="izquierdo")
            GeneradorSprites.dibujar_brazo(surf, centro_x + offset_x, cabeza_y + 40,
                                           -angulo_brazos, color_principal, lado="derecho")

            # Piernas corriendo
            angulo_piernas = math.sin(frame * 1.5 + 0.5) * 1.2
            GeneradorSprites.dibujar_pierna(surf, centro_x + offset_x, cabeza_y + 100,
                                            angulo_piernas, color_principal, lado="izquierdo")
            GeneradorSprites.dibujar_pierna(surf, centro_x + offset_x, cabeza_y + 100,
                                            -angulo_piernas, color_principal, lado="derecho")

        elif estado == "attack":
            # Cabeza
            pygame.draw.circle(surf, color_principal, (centro_x, cabeza_y), 30)

            # Cuerpo atacando
            cuerpo_rect = pygame.Rect(centro_x - 25, cabeza_y + 30, 50, 80)
            pygame.draw.rect(surf, color_principal, cuerpo_rect, border_radius=10)

            # Brazo atacando extendido
            angulo_ataque = math.pi * 0.7
            GeneradorSprites.dibujar_brazo(surf, centro_x, cabeza_y + 40,
                                           angulo_ataque, color_principal, largo=60, lado="derecho")

            # Brazo no atacante
            GeneradorSprites.dibujar_brazo(surf, centro_x, cabeza_y + 40,
                                           -0.5, color_principal, lado="izquierdo")

            # Piernas estables
            GeneradorSprites.dibujar_pierna(surf, centro_x, cabeza_y + 100,
                                            0.2, color_principal, lado="izquierdo")
            GeneradorSprites.dibujar_pierna(surf, centro_x, cabeza_y + 100,
                                            -0.2, color_principal, lado="derecho")

            # Efecto de ataque
            if frame % 2 == 0:
                efecto_x = centro_x + 80
                efecto_y = cabeza_y + 40
                for i in range(5):
                    radio = 10 + i * 3
                    alpha = 150 - i * 30
                    color_efecto = (255, 255, 200, alpha)
                    pygame.draw.circle(surf, color_efecto, (efecto_x, efecto_y), radio, 2)

        elif estado == "hurt":
            # Cabeza inclinada
            pygame.draw.circle(surf, color_claro, (centro_x, cabeza_y), 30)

            # Cuerpo doblado
            cuerpo_rect = pygame.Rect(centro_x - 25, cabeza_y + 30, 50, 80)
            pygame.draw.rect(surf, color_claro, cuerpo_rect, border_radius=10)

            # Brazos ca√≠dos
            GeneradorSprites.dibujar_brazo(surf, centro_x, cabeza_y + 40,
                                           1.5, color_claro, lado="izquierdo")
            GeneradorSprites.dibujar_brazo(surf, centro_x, cabeza_y + 40,
                                           1.8, color_claro, lado="derecho")

            # Piernas flexionadas
            GeneradorSprites.dibujar_pierna(surf, centro_x, cabeza_y + 100,
                                            0.8, color_claro, lado="izquierdo")
            GeneradorSprites.dibujar_pierna(surf, centro_x, cabeza_y + 100,
                                            1.0, color_claro, lado="derecho")

            # Efecto de da√±o
            for i in range(3):
                x = random.randint(centro_x - 40, centro_x + 40)
                y = random.randint(cabeza_y - 20, cabeza_y + 120)
                radio = random.randint(2, 5)
                pygame.draw.circle(surf, (255, 100, 100, 150), (x, y), radio)

        # Detalles faciales
        GeneradorSprites.dibujar_cara(surf, centro_x, cabeza_y, estado, frame)

        # Borde del sprite
        pygame.draw.rect(surf, color_oscuro, surf.get_rect(), 3)

        return surf

    @staticmethod
    def dibujar_brazo(surf, x, y, angulo, color, largo=40, lado="derecho"):
        """Dibuja un brazo en una posici√≥n y √°ngulo"""
        if lado == "izquierdo":
            x_inicio = x - 25
        else:
            x_inicio = x + 25

        y_inicio = y

        x_final = x_inicio + math.cos(angulo) * largo
        y_final = y_inicio + math.sin(angulo) * largo

        pygame.draw.line(surf, color, (x_inicio, y_inicio),
                         (x_final, y_final), 10)
        pygame.draw.circle(surf, color, (int(x_final), int(y_final)), 8)

    @staticmethod
    def dibujar_pierna(surf, x, y, angulo, color, largo=60, lado="izquierdo"):
        """Dibuja una pierna en una posici√≥n y √°ngulo"""
        if lado == "izquierdo":
            x_inicio = x - 15
        else:
            x_inicio = x + 15

        y_inicio = y

        x_final = x_inicio + math.cos(angulo) * largo
        y_final = y_inicio + math.sin(angulo) * largo

        pygame.draw.line(surf, color, (x_inicio, y_inicio),
                         (x_final, y_final), 12)
        pygame.draw.circle(surf, color, (int(x_final), int(y_final)), 10)

    @staticmethod
    def dibujar_cara(surf, x, y, estado, frame):
        """Dibuja la cara del personaje"""
        # Ojos
        if estado == "attack":
            # Ojos enfocados
            pygame.draw.circle(surf, (255, 255, 255), (x - 10, y), 8)
            pygame.draw.circle(surf, (255, 255, 255), (x + 10, y), 8)
            pygame.draw.circle(surf, (0, 0, 0), (x - 10, y), 4)
            pygame.draw.circle(surf, (0, 0, 0), (x + 10, y), 4)

            # Cejas enojadas
            pygame.draw.line(surf, (0, 0, 0), (x - 18, y - 15), (x - 5, y - 10), 3)
            pygame.draw.line(surf, (0, 0, 0), (x + 5, y - 10), (x + 18, y - 15), 3)

        elif estado == "hurt":
            # Ojos cerrados/da√±ados
            pygame.draw.arc(surf, (0, 0, 0), (x - 18, y - 5, 16, 8), 0, math.pi, 3)
            pygame.draw.arc(surf, (0, 0, 0), (x + 2, y - 5, 16, 8), 0, math.pi, 3)

        else:
            # Ojos normales
            pygame.draw.circle(surf, (255, 255, 255), (x - 10, y), 8)
            pygame.draw.circle(surf, (255, 255, 255), (x + 10, y), 8)
            pygame.draw.circle(surf, (0, 0, 0), (x - 10, y), 4)
            pygame.draw.circle(surf, (0, 0, 0), (x + 10, y), 4)

            # Parpadeo ocasional
            if frame % 60 < 3:
                pygame.draw.line(surf, (0, 0, 0), (x - 14, y), (x - 6, y), 3)
                pygame.draw.line(surf, (0, 0, 0), (x + 6, y), (x + 14, y), 3)

        # Boca
        if estado == "attack":
            # Boca gritando
            pygame.draw.arc(surf, (255, 0, 0), (x - 15, y + 10, 30, 20), 0, math.pi, 3)
        elif estado == "hurt":
            # Boca de dolor
            pygame.draw.arc(surf, (255, 0, 0), (x - 10, y + 15, 20, 10), math.pi, 2 * math.pi, 3)
        else:
            # Boca sonriente
            pygame.draw.arc(surf, (0, 0, 0), (x - 10, y + 10, 20, 10), 0, math.pi, 3)


# =============================================================================
# COMPONENTES DE INTERFAZ
# =============================================================================

class Boton:
    def __init__(self, x, y, ancho, alto, texto="", color=(100, 100, 255),
                 color_hover=(150, 150, 255), color_texto=(255, 255, 255)):
        self.rect = pygame.Rect(x, y, ancho, alto)
        self.texto = texto
        self.color = color
        self.color_hover = color_hover
        self.color_texto = color_texto
        self.hover = False
        self.fuente = pygame.font.SysFont('Arial', 24, bold=True)

    def dibujar(self, superficie):
        # Dibujar fondo
        color_actual = self.color_hover if self.hover else self.color
        pygame.draw.rect(superficie, color_actual, self.rect, border_radius=12)
        pygame.draw.rect(superficie, (255, 255, 255), self.rect, 3, border_radius=12)

        # Dibujar texto si existe
        if self.texto:
            texto_render = self.fuente.render(self.texto, True, self.color_texto)
            texto_rect = texto_render.get_rect(center=self.rect.center)
            superficie.blit(texto_render, texto_rect)

    def actualizar(self, pos_mouse):
        self.hover = self.rect.collidepoint(pos_mouse)
        return self.hover

    def clic(self, pos_mouse):
        return self.hover and pygame.mouse.get_pressed()[0]


class TarjetaPersonaje:
    def __init__(self, x, y, clase, jugador_num):
        self.rect = pygame.Rect(x, y, 350, 450)
        self.clase = clase
        self.jugador_num = jugador_num
        self.info = CLASES_PERSONAJE[clase]
        self.seleccionado = False
        self.fuente_titulo = pygame.font.SysFont('Arial', 28, bold=True)
        self.fuente_texto = pygame.font.SysFont('Arial', 20)
        self.fuente_stats = pygame.font.SysFont('Arial', 18)

    def dibujar(self, superficie):
        # Fondo
        color_fondo = self.info["color_oscuro"] if self.seleccionado else (40, 40, 80)
        pygame.draw.rect(superficie, color_fondo, self.rect, border_radius=15)

        # Borde
        color_borde = self.info["color_claro"] if self.seleccionado else (80, 80, 120)
        pygame.draw.rect(superficie, color_borde, self.rect, 4, border_radius=15)

        # T√≠tulo del jugador
        color_jugador = (100, 200, 255) if self.jugador_num == 1 else (255, 100, 100)
        titulo_texto = f"JUGADOR {self.jugador_num}"
        titulo = self.fuente_titulo.render(titulo_texto, True, color_jugador)
        superficie.blit(titulo, (self.rect.centerx - titulo.get_width() // 2, self.rect.top + 20))

        # Icono y nombre de clase
        icono_texto = f"{self.info['icono']} {self.info['nombre']}"
        icono = self.fuente_titulo.render(icono_texto, True, self.info["color_claro"])
        superficie.blit(icono, (self.rect.centerx - icono.get_width() // 2, self.rect.top + 60))

        # Sprite del personaje
        sprite = GeneradorSprites.crear_sprite_personaje(self.clase, "idle", 0, (200, 200))
        sprite_rect = sprite.get_rect(center=(self.rect.centerx, self.rect.top + 190))
        superficie.blit(sprite, sprite_rect)

        # Estad√≠sticas
        stats_y = self.rect.top + 290
        stats = [
            f"‚ù§Ô∏è  Vida: {self.info['vida']}",
            f"‚ö° Velocidad: {self.info['velocidad']}",
            f"üí• Da√±o: {self.info['dano_base']}",
            f"üéØ Habilidad: {self.info['habilidad']}"
        ]

        for stat in stats:
            stat_text = self.fuente_stats.render(stat, True, (200, 200, 200))
            superficie.blit(stat_text, (self.rect.left + 30, stats_y))
            stats_y += 30

        # Descripci√≥n
        desc_lines = self.wrap_text(self.info['descripcion'], self.fuente_texto, 300)
        desc_y = stats_y + 10
        for line in enumerate(desc_lines):
            desc_text = self.fuente_texto.render(line[1], True, (180, 180, 220))
            superficie.blit(desc_text, (self.rect.centerx - desc_text.get_width() // 2, desc_y))
            desc_y += 25

    def wrap_text(self, text, font, max_width):
        """Divide el texto en m√∫ltiples l√≠neas"""
        words = text.split(' ')
        lines = []
        current_line = []

        for word in words:
            current_line.append(word)
            test_line = ' '.join(current_line)
            test_width = font.size(test_line)[0]

            if test_width > max_width:
                current_line.pop()
                lines.append(' '.join(current_line))
                current_line = [word]

        if current_line:
            lines.append(' '.join(current_line))

        return lines


# =============================================================================
# MEN√ö PRINCIPAL MEJORADO
# =============================================================================

class MenuPrincipal:
    def __init__(self, ancho, alto):
        self.ancho = ancho
        self.alto = alto
        self.botones = []
        self.inicializar_botones()
        self.tiempo_inicio = pygame.time.get_ticks()

    def inicializar_botones(self):
        """Inicializa los botones del men√∫ principal"""
        centro_x = self.ancho // 2
        y_inicio = self.alto // 2 - 100

        self.botones = [
            Boton(centro_x - 150, y_inicio, 300, 60, "üéÆ JUGAR", (50, 200, 50), (100, 255, 100)),
            Boton(centro_x - 150, y_inicio + 80, 300, 60, "‚öôÔ∏è OPCIONES", (200, 150, 50), (255, 200, 100)),
            Boton(centro_x - 150, y_inicio + 160, 300, 60, "üéÆ CONTROLES", (100, 100, 200), (150, 150, 255)),
            Boton(centro_x - 150, y_inicio + 240, 300, 60, "‚ùå SALIR", (200, 50, 50), (255, 100, 100))
        ]

    def dibujar(self, superficie, sistema_sonido):
        """Dibuja el men√∫ principal"""
        # Fondo animado
        tiempo_actual = pygame.time.get_ticks()
        tiempo_transcurrido = (tiempo_actual - self.tiempo_inicio) / 1000

        # Gradiente de fondo - CORREGIDO: asegurar que los valores est√©n entre 0-255
        for y in range(self.alto):
            # Usar valores absolutos y asegurar que est√©n en rango
            sin_val1 = math.sin(y / 100 + tiempo_transcurrido)
            sin_val2 = math.sin(y / 150 + tiempo_transcurrido * 1.5)
            sin_val3 = math.sin(y / 200 + tiempo_transcurrido * 2)

            # Asegurar que los valores est√©n entre 0-255
            color_r = max(0, min(255, 20 + int(30 * sin_val1)))
            color_g = max(0, min(255, 20 + int(30 * sin_val2)))
            color_b = max(0, min(255, 40 + int(40 * sin_val3)))

            pygame.draw.line(superficie, (color_r, color_g, color_b), (0, y), (self.ancho, y))

        # Part√≠culas de fondo
        for i in range(20):
            x = (tiempo_transcurrido * 50 + i * 100) % (self.ancho + 200) - 100
            y = self.alto // 3 + math.sin(tiempo_transcurrido + i) * 50
            tama√±o = 2 + abs(math.sin(tiempo_transcurrido * 2 + i)) * 1
            color = (
                max(0, min(255, 150 + int(50 * math.sin(i)))),
                max(0, min(255, 150 + int(50 * math.cos(i)))),
                200
            )
            pygame.draw.circle(superficie, color, (int(x), int(y)), int(tama√±o))

        # T√≠tulo
        fuente_titulo = pygame.font.SysFont('Arial', 72, bold=True)
        fuente_subtitulo = pygame.font.SysFont('Arial', 32)

        titulo = fuente_titulo.render("STICK MAN ARENA", True, (255, 255, 255))
        subtitulo = fuente_subtitulo.render("EDICI√ìN √âPICA", True, (255, 215, 0))

        # Efecto de brillo en el t√≠tulo
        for offset in range(3):
            color_brillo = (
                max(0, min(255, 255 - offset * 50)),
                max(0, min(255, 255 - offset * 30)),
                max(0, min(255, 200 - offset * 20))
            )
            titulo_shadow = fuente_titulo.render("STICK MAN ARENA", True, color_brillo)
            superficie.blit(titulo_shadow, (self.ancho // 2 - titulo_shadow.get_width() // 2 + offset,
                                            self.alto // 4 + offset))

        superficie.blit(titulo, (self.ancho // 2 - titulo.get_width() // 2, self.alto // 4))
        superficie.blit(subtitulo, (self.ancho // 2 - subtitulo.get_width() // 2, self.alto // 4 + 80))

        # Versi√≥n
        version = fuente_subtitulo.render("v2.0", True, (150, 150, 150))
        superficie.blit(version, (20, self.alto - 40))

        # Actualizar y dibujar botones
        pos_mouse = pygame.mouse.get_pos()
        for boton in self.botones:
            if boton.actualizar(pos_mouse):
                # Efecto hover
                if not hasattr(boton, 'hover_sound_played'):
                    sistema_sonido.reproducir('menu_navigate')
                    boton.hover_sound_played = True
            else:
                if hasattr(boton, 'hover_sound_played'):
                    delattr(boton, 'hover_sound_played')

            boton.dibujar(superficie)

    def manejar_eventos(self, eventos, sistema_sonido):
        """Maneja los eventos del men√∫ principal"""
        for evento in eventos:
            if evento.type == pygame.KEYDOWN:
                if evento.key == pygame.K_ESCAPE:
                    return "salir"
                elif evento.key == pygame.K_RETURN:
                    sistema_sonido.reproducir('menu_select')
                    return "jugar"

            elif evento.type == pygame.MOUSEBUTTONDOWN:
                if evento.button == 1:  # Clic izquierdo
                    pos_mouse = pygame.mouse.get_pos()
                    for i, boton in enumerate(self.botones):
                        if boton.rect.collidepoint(pos_mouse):
                            sistema_sonido.reproducir('menu_select')
                            if i == 0:  # JUGAR
                                return "jugar"
                            elif i == 1:  # OPCIONES
                                return "opciones"
                            elif i == 2:  # CONTROLES
                                return "controles"
                            elif i == 3:  # SALIR
                                return "salir"

        return None


# =============================================================================
# MEN√ö DE SELECCI√ìN DE MODO MEJORADO
# =============================================================================

class MenuSeleccionModo:
    def __init__(self, ancho, alto):
        self.ancho = ancho
        self.alto = alto
        self.modos = list(CONFIG_MODOS.items())
        self.tarjetas = []
        self.boton_volver = Boton(50, alto - 80, 200, 50, "‚¨ÖÔ∏è VOLVER",
                                  (200, 100, 100), (255, 150, 150))
        self.inicializar_tarjetas()

    def inicializar_tarjetas(self):
        """Inicializa las tarjetas de modo"""
        espacio_entre = 50
        ancho_tarjeta = 400
        x_inicio = (self.ancho - (len(self.modos) * ancho_tarjeta +
                                  (len(self.modos) - 1) * espacio_entre)) // 2

        for i, (modo, info) in enumerate(self.modos):
            x = x_inicio + i * (ancho_tarjeta + espacio_entre)
            y = self.alto // 3
            self.tarjetas.append({
                "modo": modo,
                "info": info,
                "rect": pygame.Rect(x, y, ancho_tarjeta, 350),
                "seleccionado": False
            })

    def dibujar(self, superficie):
        """Dibuja el men√∫ de selecci√≥n de modo"""
        # Fondo
        superficie.fill((30, 30, 60))

        # T√≠tulo
        fuente_titulo = pygame.font.SysFont('Arial', 48, bold=True)
        titulo = fuente_titulo.render("SELECCIONA MODO DE JUEGO", True, (255, 255, 255))
        superficie.blit(titulo, (self.ancho // 2 - titulo.get_width() // 2, 50))

        # Instrucciones
        fuente_inst = pygame.font.SysFont('Arial', 20)
        instrucciones = fuente_inst.render("Haz clic en un modo para seleccionarlo", True, (200, 200, 200))
        superficie.blit(instrucciones, (self.ancho // 2 - instrucciones.get_width() // 2, 120))

        # Dibujar tarjetas
        pos_mouse = pygame.mouse.get_pos()
        for tarjeta in self.tarjetas:
            # Determinar si est√° seleccionada o en hover
            hover = tarjeta["rect"].collidepoint(pos_mouse)
            seleccionada = tarjeta["seleccionado"]

            # Color de fondo
            if seleccionada:
                color_fondo = tarjeta["info"]["color"]
                color_borde = (255, 255, 255)
            elif hover:
                color_fondo = tuple(min(c + 30, 255) for c in tarjeta["info"]["color"])
                color_borde = (200, 200, 200)
            else:
                color_fondo = tuple(max(c - 30, 50) for c in tarjeta["info"]["color"])
                color_borde = (100, 100, 100)

            # Dibujar tarjeta
            pygame.draw.rect(superficie, color_fondo, tarjeta["rect"], border_radius=20)
            pygame.draw.rect(superficie, color_borde, tarjeta["rect"], 4, border_radius=20)

            # Contenido de la tarjeta
            x = tarjeta["rect"].centerx
            y = tarjeta["rect"].top + 30

            # Icono
            fuente_icono = pygame.font.SysFont('Arial', 48)
            icono = fuente_icono.render(tarjeta["info"]["icono"], True, (255, 255, 255))
            superficie.blit(icono, (x - icono.get_width() // 2, y))

            # Nombre
            fuente_nombre = pygame.font.SysFont('Arial', 32, bold=True)
            nombre = fuente_nombre.render(tarjeta["info"]["nombre"], True, (255, 255, 255))
            superficie.blit(nombre, (x - nombre.get_width() // 2, y + 60))

            # Descripci√≥n
            fuente_desc = pygame.font.SysFont('Arial', 18)
            lineas = self.dividir_texto(tarjeta["info"]["descripcion"], fuente_desc, tarjeta["rect"].width - 40)
            for j, linea in enumerate(lineas):
                texto = fuente_desc.render(linea, True, (230, 230, 230))
                superficie.blit(texto, (tarjeta["rect"].left + 20, y + 120 + j * 25))

        # Dibujar bot√≥n volver
        self.boton_volver.actualizar(pos_mouse)
        self.boton_volver.dibujar(superficie)

    def dividir_texto(self, texto, fuente, max_ancho):
        """Divide el texto en m√∫ltiples l√≠neas"""
        palabras = texto.split('\n')
        lineas = []

        for bloque in palabras:
            palabras_bloque = bloque.split(' ')
            linea_actual = []

            for palabra in palabras_bloque:
                linea_actual.append(palabra)
                prueba = ' '.join(linea_actual)
                if fuente.size(prueba)[0] > max_ancho:
                    linea_actual.pop()
                    lineas.append(' '.join(linea_actual))
                    linea_actual = [palabra]

            if linea_actual:
                lineas.append(' '.join(linea_actual))

        return lineas

    def manejar_eventos(self, eventos, sistema_sonido):
        """Maneja los eventos del men√∫ de selecci√≥n de modo"""
        pos_mouse = pygame.mouse.get_pos()

        for evento in eventos:
            if evento.type == pygame.KEYDOWN:
                if evento.key == pygame.K_ESCAPE:
                    sistema_sonido.reproducir('menu_select')
                    return "menu"

            elif evento.type == pygame.MOUSEBUTTONDOWN:
                if evento.button == 1:  # Clic izquierdo
                    # Verificar tarjetas
                    for tarjeta in self.tarjetas:
                        if tarjeta["rect"].collidepoint(pos_mouse):
                            sistema_sonido.reproducir('menu_select')
                            # Seleccionar esta tarjeta
                            for t in self.tarjetas:
                                t["seleccionado"] = False
                            tarjeta["seleccionado"] = True
                            return tarjeta["modo"]

                    # Verificar bot√≥n volver
                    if self.boton_volver.rect.collidepoint(pos_mouse):
                        sistema_sonido.reproducir('menu_select')
                        return "menu"

        return None


# =============================================================================
# MEN√ö DE SELECCI√ìN DE PERSONAJE MEJORADO
# =============================================================================

class MenuSeleccionPersonaje:
    def __init__(self, ancho, alto):
        self.ancho = ancho
        self.alto = alto
        self.personaje_j1 = "guerrero"
        self.personaje_j2 = "asesino"
        self.botones = []
        self.inicializar_botones()

    def inicializar_botones(self):
        """Inicializa los botones del men√∫"""
        # Botones de selecci√≥n J1
        self.botones.append({
            "tipo": "flecha_j1_izq",
            "rect": pygame.Rect(self.ancho // 4 - 100, self.alto // 2, 50, 50),
            "accion": lambda: self.cambiar_personaje(1, -1)
        })

        self.botones.append({
            "tipo": "flecha_j1_der",
            "rect": pygame.Rect(self.ancho // 4 + 50, self.alto // 2, 50, 50),
            "accion": lambda: self.cambiar_personaje(1, 1)
        })

        # Botones de selecci√≥n J2
        self.botones.append({
            "tipo": "flecha_j2_izq",
            "rect": pygame.Rect(3 * self.ancho // 4 - 100, self.alto // 2, 50, 50),
            "accion": lambda: self.cambiar_personaje(2, -1)
        })

        self.botones.append({
            "tipo": "flecha_j2_der",
            "rect": pygame.Rect(3 * self.ancho // 4 + 50, self.alto // 2, 50, 50),
            "accion": lambda: self.cambiar_personaje(2, 1)
        })

        # Botones de control
        self.boton_empezar = Boton(self.ancho // 2 - 150, self.alto - 120, 300, 60,
                                   "üéÆ EMPEZAR PARTIDA", (50, 200, 50), (100, 255, 100))
        self.boton_volver = Boton(50, self.alto - 80, 200, 50, "‚¨ÖÔ∏è VOLVER",
                                  (200, 100, 100), (255, 150, 150))

    def cambiar_personaje(self, jugador, direccion):
        """Cambia el personaje seleccionado"""
        clases = list(CLASES_PERSONAJE.keys())

        if jugador == 1:
            indice_actual = clases.index(self.personaje_j1)
            nuevo_indice = (indice_actual + direccion) % len(clases)
            self.personaje_j1 = clases[nuevo_indice]
        else:
            indice_actual = clases.index(self.personaje_j2)
            nuevo_indice = (indice_actual + direccion) % len(clases)
            self.personaje_j2 = clases[nuevo_indice]

    def dibujar(self, superficie, sistema_sonido):
        """Dibuja el men√∫ de selecci√≥n de personaje"""
        # Fondo
        superficie.fill((25, 25, 50))

        # T√≠tulo
        fuente_titulo = pygame.font.SysFont('Arial', 48, bold=True)
        titulo = fuente_titulo.render("SELECCIONA TU PERSONAJE", True, (255, 255, 255))
        superficie.blit(titulo, (self.ancho // 2 - titulo.get_width() // 2, 40))

        # Tarjetas de personaje
        tarjeta_j1 = TarjetaPersonaje(self.ancho // 4 - 175, self.alto // 4,
                                      self.personaje_j1, 1)
        tarjeta_j2 = TarjetaPersonaje(3 * self.ancho // 4 - 175, self.alto // 4,
                                      self.personaje_j2, 2)

        tarjeta_j1.dibujar(superficie)
        tarjeta_j2.dibujar(superficie)

        # Dibujar flechas de selecci√≥n
        pos_mouse = pygame.mouse.get_pos()
        for boton in self.botones:
            hover = boton["rect"].collidepoint(pos_mouse)
            color = (200, 200, 255) if hover else (150, 150, 200)

            # Dibujar flecha
            if "izq" in boton["tipo"]:
                # Flecha izquierda
                puntos = [
                    (boton["rect"].right, boton["rect"].top),
                    (boton["rect"].left, boton["rect"].centery),
                    (boton["rect"].right, boton["rect"].bottom)
                ]
            else:
                # Flecha derecha
                puntos = [
                    (boton["rect"].left, boton["rect"].top),
                    (boton["rect"].right, boton["rect"].centery),
                    (boton["rect"].left, boton["rect"].bottom)
                ]

            pygame.draw.polygon(superficie, color, puntos)
            pygame.draw.polygon(superficie, (255, 255, 255), puntos, 2)

        # Dibujar botones de control
        self.boton_empezar.actualizar(pos_mouse)
        self.boton_volver.actualizar(pos_mouse)

        self.boton_empezar.dibujar(superficie)
        self.boton_volver.dibujar(superficie)

        # Instrucciones de controles
        fuente_inst = pygame.font.SysFont('Arial', 22)

        controles_j1 = [
            "CONTROLES JUGADOR 1:",
            "‚Üê ‚Üí : Moverse",
            "‚Üë : Saltar",
            "Z : Ataque r√°pido",
            "X : Ataque pesado",
            "C : Ataque a√©reo",
            "A : Bloquear",
            "S : Habilidad"
        ]

        controles_j2 = [
            "CONTROLES JUGADOR 2:",
            "A D : Moverse",
            "W : Saltar",
            "F : Ataque r√°pido",
            "G : Ataque pesado",
            "H : Ataque a√©reo",
            "J : Bloquear",
            "K : Habilidad"
        ]

        # Dibujar controles J1
        y_controles = self.alto - 250
        for i, texto in enumerate(controles_j1):
            color = (100, 200, 255) if i == 0 else (200, 200, 200)
            texto_render = fuente_inst.render(texto, True, color)
            superficie.blit(texto_render, (self.ancho // 4 - 150, y_controles + i * 25))

        # Dibujar controles J2
        for i, texto in enumerate(controles_j2):
            color = (255, 100, 100) if i == 0 else (200, 200, 200)
            texto_render = fuente_inst.render(texto, True, color)
            superficie.blit(texto_render, (3 * self.ancho // 4 - 150, y_controles + i * 25))

    def manejar_eventos(self, eventos, sistema_sonido):
        """Maneja los eventos del men√∫"""
        pos_mouse = pygame.mouse.get_pos()

        for evento in eventos:
            if evento.type == pygame.KEYDOWN:
                if evento.key == pygame.K_ESCAPE:
                    sistema_sonido.reproducir('menu_select')
                    return "menu"
                elif evento.key == pygame.K_RETURN:
                    sistema_sonido.reproducir('menu_select')
                    return ("empezar", self.personaje_j1, self.personaje_j2)

            elif evento.type == pygame.MOUSEBUTTONDOWN:
                if evento.button == 1:
                    # Verificar flechas
                    for boton in self.botones:
                        if boton["rect"].collidepoint(pos_mouse):
                            sistema_sonido.reproducir('menu_navigate')
                            boton["accion"]()
                            break

                    # Verificar bot√≥n empezar
                    if self.boton_empezar.rect.collidepoint(pos_mouse):
                        sistema_sonido.reproducir('menu_select')
                        return ("empezar", self.personaje_j1, self.personaje_j2)

                    # Verificar bot√≥n volver
                    if self.boton_volver.rect.collidepoint(pos_mouse):
                        sistema_sonido.reproducir('menu_select')
                        return "menu"

        return None


# =============================================================================
# MEN√ö DE CONTROLES
# =============================================================================

class MenuControles:
    def __init__(self, ancho, alto):
        self.ancho = ancho
        self.alto = alto
        self.boton_volver = Boton(50, alto - 80, 200, 50, "‚¨ÖÔ∏è VOLVER",
                                  (200, 100, 100), (255, 150, 150))

    def dibujar(self, superficie):
        """Dibuja el men√∫ de controles"""
        # Fondo
        superficie.fill((20, 20, 40))

        # T√≠tulo
        fuente_titulo = pygame.font.SysFont('Arial', 48, bold=True)
        titulo = fuente_titulo.render("CONTROLES DEL JUEGO", True, (255, 255, 255))
        superficie.blit(titulo, (self.ancho // 2 - titulo.get_width() // 2, 50))

        # Panel de controles
        panel_rect = pygame.Rect(self.ancho // 4, 150, self.ancho // 2, self.alto - 300)
        pygame.draw.rect(superficie, (40, 40, 80), panel_rect, border_radius=20)
        pygame.draw.rect(superficie, (100, 100, 200), panel_rect, 4, border_radius=20)

        # Controles J1
        fuente_subtitulo = pygame.font.SysFont('Arial', 32, bold=True)
        fuente_control = pygame.font.SysFont('Arial', 24)

        # JUGADOR 1 (Teclado Izquierdo)
        titulo_j1 = fuente_subtitulo.render("üéÆ JUGADOR 1", True, (100, 200, 255))
        superficie.blit(titulo_j1, (panel_rect.centerx - titulo_j1.get_width() // 2, 180))

        controles_j1 = [
            ("Flechas ‚Üê ‚Üí", "Moverse izquierda/derecha"),
            ("Flecha ‚Üë", "Saltar"),
            ("Tecla Z", "Ataque r√°pido"),
            ("Tecla X", "Ataque pesado"),
            ("Tecla C", "Ataque a√©reo"),
            ("Tecla A", "Bloquear (reduce da√±o)"),
            ("Tecla S", "Habilidad especial"),
            ("Tecla Q", "Cargar poder especial"),
            ("Tecla 1-4", "Cambiar personaje (en men√∫)")
        ]

        y_actual = 240
        for tecla, accion in controles_j1:
            # Tecla
            tecla_text = fuente_control.render(tecla, True, (255, 255, 150))
            superficie.blit(tecla_text, (panel_rect.left + 50, y_actual))

            # Acci√≥n
            accion_text = fuente_control.render(accion, True, (200, 200, 200))
            superficie.blit(accion_text, (panel_rect.left + 250, y_actual))

            y_actual += 40

        # Separador
        pygame.draw.line(superficie, (100, 100, 150),
                         (panel_rect.left + 50, y_actual + 20),
                         (panel_rect.right - 50, y_actual + 20), 2)

        y_actual += 40

        # JUGADOR 2 (Teclado Derecho)
        titulo_j2 = fuente_subtitulo.render("üéÆ JUGADOR 2", True, (255, 100, 100))
        superficie.blit(titulo_j2, (panel_rect.centerx - titulo_j2.get_width() // 2, y_actual))

        y_actual += 40

        controles_j2 = [
            ("Teclas A D", "Moverse izquierda/derecha"),
            ("Tecla W", "Saltar"),
            ("Tecla F", "Ataque r√°pido"),
            ("Tecla G", "Ataque pesado"),
            ("Tecla H", "Ataque a√©reo"),
            ("Tecla J", "Bloquear (reduce da√±o)"),
            ("Tecla K", "Habilidad especial"),
            ("Tecla E", "Cargar poder especial"),
            ("Tecla 5-8", "Cambiar personaje (en men√∫)")
        ]

        for tecla, accion in controles_j2:
            # Tecla
            tecla_text = fuente_control.render(tecla, True, (255, 150, 150))
            superficie.blit(tecla_text, (panel_rect.left + 50, y_actual))

            # Acci√≥n
            accion_text = fonte_control.render(accion, True, (200, 200, 200))
            superficie.blit(accion_text, (panel_rect.left + 250, y_actual))

            y_actual += 40

        # Controles generales
        y_actual += 20
        titulo_general = fuente_subtitulo.render("üéÆ CONTROLES GENERALES", True, (255, 255, 100))
        superficie.blit(titulo_general, (panel_rect.centerx - titulo_general.get_width() // 2, y_actual))

        y_actual += 40

        controles_general = [
            ("ESC", "Volver al men√∫ / Salir"),
            ("ENTER", "Confirmar selecci√≥n"),
            ("ESPACIO", "Saltar di√°logo / Pausa"),
            ("F1", "Mostrar/Ocultar FPS"),
            ("F11", "Pantalla completa/Ventana"),
            ("F12", "Capturar pantalla")
        ]

        for tecla, accion in controles_general:
            # Tecla
            tecla_text = fuente_control.render(tecla, True, (200, 255, 200))
            superficie.blit(tecla_text, (panel_rect.left + 50, y_actual))

            # Acci√≥n
            accion_text = fuente_control.render(accion, True, (200, 200, 200))
            superficie.blit(accion_text, (panel_rect.left + 250, y_actual))

            y_actual += 35

        # Consejos
        y_actual += 30
        fuente_consejo = pygame.font.SysFont('Arial', 20, italic=True)
        consejos = [
            "üí° Consejo: Mant√©n pulsado el bloqueo para reducir el da√±o recibido",
            "üí° Consejo: Los ataques a√©reos son m√°s efectivos contra oponentes saltando",
            "üí° Consejo: Carga tu habilidad especial con ataques exitosos",
            "üí° Consejo: Combina ataques r√°pidos y pesados para mejores combos"
        ]

        for consejo in consejos:
            consejo_text = fuente_consejo.render(consejo, True, (150, 200, 255))
            superficie.blit(consejo_text, (panel_rect.left + 30, y_actual))
            y_actual += 30

        # Dibujar bot√≥n volver
        self.boton_volver.actualizar(pygame.mouse.get_pos())
        self.boton_volver.dibujar(superficie)

    def manejar_eventos(self, eventos, sistema_sonido):
        """Maneja los eventos del men√∫ de controles"""
        for evento in eventos:
            if evento.type == pygame.KEYDOWN:
                if evento.key == pygame.K_ESCAPE:
                    sistema_sonido.reproducir('menu_select')
                    return "menu"

            elif evento.type == pygame.MOUSEBUTTONDOWN:
                if evento.button == 1:
                    pos_mouse = pygame.mouse.get_pos()
                    if self.boton_volver.rect.collidepoint(pos_mouse):
                        sistema_sonido.reproducir('menu_select')
                        return "menu"

        return None


# =============================================================================
# JUGADOR MEJORADO
# =============================================================================

class Jugador:
    def __init__(self, x, y, clase, es_jugador1=True, modo_combos_infinitos=False):
        self.x = x
        self.y = y
        self.clase = clase
        self.info = CLASES_PERSONAJE[clase]
        self.es_jugador1 = es_jugador1
        self.modo_combos_infinitos = modo_combos_infinitos

        # Estad√≠sticas
        self.vida_maxima = self.info["vida"]
        self.vida_actual = self.vida_maxima
        self.velocidad = self.info["velocidad"]
        self.dano_base = self.info["dano_base"]

        # Estado
        self.mirando_derecha = es_jugador1
        self.esta_saltando = False
        self.esta_atacando = False
        self.esta_bloqueando = False
        self.esta_recibiendo_dano = False
        self.invencible = False
        self.tiempo_invencibilidad = 0

        # F√≠sica
        self.velocidad_y = 0
        self.gravedad = 0.8
        self.fuerza_salto = -18
        self.velocidad_caida_maxima = 25

        # Combos
        self.combo_actual = 0
        self.combo_tiempo = 0
        self.combo_max_tiempo = 180  # 3 segundos a 60 FPS
        self.mejor_combo = 0
        self.dano_combo_extra = 0

        # Animaci√≥n
        self.estado_animacion = "idle"
        self.frame_animacion = 0
        self.tiempo_frame = 0
        self.velocidad_animacion = 8

        # Ataque
        self.tipo_ataque = None
        self.tiempo_ataque = 0
        self.duracion_ataque = 15

        # Habilidad especial
        self.habilidad_cargada = False
        self.carga_habilidad = 0
        self.carga_maxima = 100

        # Hitboxes
        self.rect_colision = pygame.Rect(x + 50, y + 50, 100, 150)
        self.hitbox_ataque = None

        # Efectos
        self.efecto_dano = 0
        self.efecto_combo = 0
        self.particulas = []

    def actualizar(self, teclas, plataformas):
        """Actualiza el estado del jugador"""
        # Actualizar invencibilidad
        if self.invencible:
            if pygame.time.get_ticks() > self.tiempo_invencibilidad:
                self.invencible = False

        # Actualizar efectos
        if self.efecto_dano > 0:
            self.efecto_dano -= 1
        if self.efecto_combo > 0:
            self.efecto_combo -= 1

        # Actualizar combo
        if self.combo_actual > 0:
            self.combo_tiempo -= 1
            if self.combo_tiempo <= 0:
                if self.combo_actual > self.mejor_combo:
                    self.mejor_combo = self.combo_actual
                self.combo_actual = 0
                self.dano_combo_extra = 0

        # Actualizar ataque
        if self.esta_atacando:
            self.tiempo_ataque -= 1
            if self.tiempo_ataque <= 0:
                self.esta_atacando = False
                self.tipo_ataque = None
                self.hitbox_ataque = None

        # Manejar entrada
        if not self.esta_recibiendo_dano and not self.esta_atacando:
            self.manejar_entrada(teclas)

        # Aplicar gravedad
        self.velocidad_y += self.gravedad
        if self.velocidad_y > self.velocidad_caida_maxima:
            self.velocidad_y = self.velocidad_caida_maxima

        self.y += self.velocidad_y

        # Colisi√≥n con plataformas
        self.rect_colision.y = self.y + 50
        colision_suelo = False

        for plataforma in plataformas:
            if self.rect_colision.colliderect(plataforma.rect):
                if self.velocidad_y > 0:  # Cayendo
                    self.y = plataforma.rect.top - 200  # Ajustar posici√≥n
                    self.velocidad_y = 0
                    self.esta_saltando = False
                    colision_suelo = True

        # Si no hay colisi√≥n con suelo, est√° saltando
        if not colision_suelo and self.velocidad_y >= 0:
            self.esta_saltando = True

        # Actualizar rect√°ngulo de colisi√≥n
        self.rect_colision.x = self.x + 50
        self.rect_colision.y = self.y + 50

        # Actualizar animaci√≥n
        self.actualizar_animacion()

        # Actualizar hitbox de ataque
        if self.esta_atacando and self.tipo_ataque and self.tiempo_ataque > 5:
            self.actualizar_hitbox_ataque()

    def manejar_entrada(self, teclas):
        """Maneja la entrada del teclado"""
        movimiento = 0

        if self.es_jugador1:
            # Controles jugador 1
            if teclas(pygame.K_LEFT):
                movimiento -= self.velocidad
                self.mirando_derecha = False
            if teclas(pygame.K_RIGHT):
                movimiento += self.velocidad
                self.mirando_derecha = True
            if teclas(pygame.K_UP) and not self.esta_saltando:
                self.saltar()
            if teclas(pygame.K_z):
                self.atacar("rapido")
            if teclas(pygame.K_x):
                self.atacar("pesado")
            if teclas(pygame.K_c) and self.esta_saltando:
                self.atacar("aereo")
            if teclas(pygame.K_a):
                self.esta_bloqueando = True
            else:
                self.esta_bloqueando = False

        else:
            # Controles jugador 2
            if teclas(pygame.K_a):
                movimiento -= self.velocidad
                self.mirando_derecha = False
            if teclas(pygame.K_d):
                movimiento += self.velocidad
                self.mirando_derecha = True
            if teclas(pygame.K_w) and not self.esta_saltando:
                self.saltar()
            if teclas(pygame.K_f):
                self.atacar("rapido")
            if teclas(pygame.K_g):
                self.atacar("pesado")
            if teclas(pygame.K_h) and self.esta_saltando:
                self.atacar("aereo")
            if teclas(pygame.K_j):
                self.esta_bloqueando = True
            else:
                self.esta_bloqueando = False

        # Aplicar movimiento
        self.x += movimiento

        # Limitar posici√≥n
        self.x = max(0, min(self.x, ANCHO - 200))

        # Actualizar estado de animaci√≥n basado en movimiento
        if movimiento != 0 and not self.esta_saltando:
            self.estado_animacion = "run"
        elif not self.esta_atacando and not self.esta_recibiendo_dano:
            self.estado_animacion = "idle"

    def saltar(self):
        """Hace que el jugador salte"""
        self.velocidad_y = self.fuerza_salto
        self.esta_saltando = True
        self.estado_animacion = "jump"

    def atacar(self, tipo):
        """Realiza un ataque"""
        if self.esta_atacando:
            return

        self.esta_atacando = True
        self.tipo_ataque = tipo
        self.tiempo_ataque = self.duracion_ataque

        # Ajustar duraci√≥n seg√∫n tipo de ataque
        if tipo == "pesado":
            self.tiempo_ataque = 25
        elif tipo == "aereo":
            self.tiempo_ataque = 20

        self.estado_animacion = "attack"
        self.frame_animacion = 0

        # Incrementar combo
        if self.modo_combos_infinitos or tipo != "pesado":
            self.combo_actual += 1
            self.combo_tiempo = self.combo_max_tiempo
            self.efecto_combo = 30

            # Incrementar da√±o por combo
            self.dano_combo_extra = min(self.combo_actual * 0.5, 10)

    def actualizar_hitbox_ataque(self):
        """Actualiza la hitbox del ataque actual"""
        if self.tipo_ataque == "rapido":
            ancho = 80
            alto = 60
            offset = 120
        elif self.tipo_ataque == "pesado":
            ancho = 120
            alto = 80
            offset = 130
        else:  # aereo
            ancho = 100
            alto = 70
            offset = 100

        if self.mirando_derecha:
            x = self.x + offset
        else:
            x = self.x + 200 - offset - ancho

        y = self.y + 80
        self.hitbox_ataque = pygame.Rect(x, y, ancho, alto)

    def recibir_dano(self, cantidad, sistema_particulas=None):
        """Aplica da√±o al jugador"""
        if self.invencible or self.esta_recibiendo_dano:
            return False

        # Reducir da√±o si est√° bloqueando
        if self.esta_bloqueando:
            cantidad *= 0.3

        self.vida_actual = max(0, self.vida_actual - cantidad)
        self.esta_recibiendo_dano = True
        self.estado_animacion = "hurt"
        self.frame_animacion = 0
        self.efecto_dano = 15

        # Aplicar retroceso
        retroceso = 20 + (cantidad * 0.5)
        if self.mirando_derecha:
            self.x -= retroceso
        else:
            self.x += retroceso

        # Resetear combo
        self.combo_actual = 0
        self.combo_tiempo = 0
        self.dano_combo_extra = 0

        # Efectos visuales
        if sistema_particulas:
            sistema_particulas.agregar_explosion(
                self.rect_colision.centerx,
                self.rect_colision.centery,
                (255, 50, 50),
                "peque√±o"
            )

        return True

    def curar(self, cantidad):
        """Cura al jugador"""
        self.vida_actual = min(self.vida_maxima, self.vida_actual + cantidad)

    def actualizar_animacion(self):
        """Actualiza la animaci√≥n del jugador"""
        self.tiempo_frame += 1

        if self.tiempo_frame >= self.velocidad_animacion:
            self.tiempo_frame = 0
            self.frame_animacion += 1

            # Si termina animaci√≥n de da√±o
            if self.estado_animacion == "hurt" and self.frame_animacion >= 4:
                self.esta_recibiendo_dano = False
                self.estado_animacion = "idle"
                self.frame_animacion = 0

            # Si termina animaci√≥n de ataque
            if self.estado_animacion == "attack" and self.frame_animacion >= 5:
                self.esta_atacando = False
                self.estado_animacion = "idle"
                self.frame_animacion = 0

            # Loop de animaciones normales
            if self.estado_animacion in ["idle", "run", "jump"]:
                self.frame_animacion %= 8

    def dibujar(self, superficie):
        """Dibuja al jugador en la superficie"""
        # Crear sprite actual
        sprite = GeneradorSprites.crear_sprite_personaje(
            self.clase,
            self.estado_animacion,
            self.frame_animacion
        )

        # Voltear si mira a la izquierda
        if not self.mirando_derecha:
            sprite = pygame.transform.flip(sprite, True, False)

        # Efecto de da√±o
        if self.efecto_dano > 0:
            overlay = pygame.Surface(sprite.get_size(), pygame.SRCALPHA)
            alpha = min(150, self.efecto_dano * 20)
            overlay.fill((255, 100, 100, alpha))
            sprite.blit(overlay, (0, 0), special_flags=pygame.BLEND_RGBA_ADD)

        # Efecto de combo
        if self.efecto_combo > 0:
            overlay = pygame.Surface(sprite.get_size(), pygame.SRCALPHA)
            alpha = min(100, self.efecto_combo * 10)
            overlay.fill((255, 255, 100, alpha))
            sprite.blit(overlay, (0, 0), special_flags=pygame.BLEND_RGBA_ADD)

        # Dibujar sprite
        superficie.blit(sprite, (self.x, self.y))

        # Dibujar barra de vida
        self.dibujar_barra_vida(superficie)

        # Dibujar indicador de combo si hay combo activo
        if self.combo_actual > 0:
            self.dibujar_combo(superficie)

    def dibujar_barra_vida(self, superficie):
        """Dibuja la barra de vida del jugador"""
        ancho_total = 150
        alto = 20
        x = self.x + 25
        y = self.y - 30

        # Fondo
        pygame.draw.rect(superficie, (50, 50, 50), (x, y, ancho_total, alto))

        # Vida actual
        porcentaje = self.vida_actual / self.vida_maxima
        ancho_vida = int(ancho_total * porcentaje)

        # Color seg√∫n porcentaje
        if porcentaje > 0.6:
            color = (0, 200, 0)
        elif porcentaje > 0.3:
            color = (255, 200, 0)
        else:
            color = (255, 50, 0)

        pygame.draw.rect(superficie, color, (x, y, ancho_vida, alto))

        # Borde
        pygame.draw.rect(superficie, (255, 255, 255), (x, y, ancho_total, alto), 2)

        # Texto de vida
        fuente = pygame.font.SysFont('Arial', 16, bold=True)
        texto = fuente.render(f"{int(self.vida_actual)}/{self.vida_maxima}", True, (255, 255, 255))
        superficie.blit(texto, (x + ancho_total // 2 - texto.get_width() // 2, y))

    def dibujar_combo(self, superficie):
        """Dibuja el indicador de combo"""
        x = self.x + 100
        y = self.y - 60

        # Fondo del combo
        pygame.draw.rect(superficie, (30, 30, 60), (x - 40, y - 10, 80, 30), border_radius=5)
        pygame.draw.rect(superficie, (100, 100, 200), (x - 40, y - 10, 80, 30), 2, border_radius=5)

        # Texto del combo
        fuente = pygame.font.SysFont('Arial', 20, bold=True)
        texto = fuente.render(f"COMBO x{self.combo_actual}", True, (255, 255, 0))
        superficie.blit(texto, (x - texto.get_width() // 2, y - 5))

        # Tiempo restante del combo
        tiempo_restante = self.combo_tiempo / self.combo_max_tiempo
        ancho_barra = 70
        pygame.draw.rect(superficie, (50, 50, 50), (x - ancho_barra // 2, y + 25, ancho_barra, 5))
        pygame.draw.rect(superficie, (0, 255, 0),
                         (x - ancho_barra // 2, y + 25, int(ancho_barra * tiempo_restante), 5))

    def get_dano_ataque(self):
        """Calcula el da√±o del ataque actual"""
        dano = self.dano_base + self.dano_combo_extra

        if self.tipo_ataque == "pesado":
            dano *= 1.8
        elif self.tipo_ataque == "aereo":
            dano *= 1.4

        return int(dano)


# =============================================================================
# PLATAFORMA
# =============================================================================

class Plataforma:
    def __init__(self, x, y, ancho, alto, color=None):
        self.rect = pygame.Rect(x, y, ancho, alto)
        self.color = color or (120, 80, 40)
        self.color_borde = (80, 50, 20)

    def dibujar(self, superficie):
        """Dibuja la plataforma"""
        pygame.draw.rect(superficie, self.color, self.rect)
        pygame.draw.rect(superficie, self.color_borde, self.rect, 3)

        # Detalles de textura
        for i in range(0, self.rect.width, 20):
            for j in range(0, self.rect.height, 20):
                x = self.rect.x + i + random.randint(0, 10)
                y = self.rect.y + j + random.randint(0, 10)
                pygame.draw.rect(superficie, self.color_borde, (x, y, 5, 5))


# =============================================================================
# JUEGO PRINCIPAL
# =============================================================================

class Juego:
    def __init__(self):
        self.ancho = ANCHO
        self.alto = ALTO

        # Sistemas
        self.sistema_sonido = SistemaSonido()
        self.sistema_particulas = SistemaParticulas()
        self.sistema_progresion = SistemaProgresion()

        # Estado del juego
        self.estado = EstadoJuego.MENU
        self.modo_actual = None
        self.personaje_j1 = "guerrero"
        self.personaje_j2 = "asesino"

        # Jugadores
        self.jugador1 = None
        self.jugador2 = None

        # Elementos del juego
        self.plataformas = []
        self.tiempo_juego = 0
        self.vidas_j1 = 3
        self.vidas_j2 = 3
        self.puntuacion_j1 = 0
        self.puntuacion_j2 = 0
        self.oleada_actual = 1

        # Men√∫s
        self.menu_principal = MenuPrincipal(ANCHO, ALTO)
        self.menu_seleccion_modo = MenuSeleccionModo(ANCHO, ALTO)
        self.menu_seleccion_personaje = MenuSeleccionPersonaje(ANCHO, ALTO)
        self.menu_controles = MenuControles(ANCHO, ALTO)

        # Fondo
        self.fondo = self.crear_fondo()
        self.tiempo_fondo = 0

        # Control de FPS
        self.clock = pygame.time.Clock()
        self.fps = 60
        self.mostrar_fps = True

    def crear_fondo(self):
        """Crea un fondo din√°mico para el juego"""
        fondo = pygame.Surface((self.ancho, self.alto))

        # Gradiente base
        for y in range(self.alto):
            color_r = 20 + int(30 * (y / self.alto))
            color_g = 25 + int(40 * (y / self.alto))
            color_b = 40 + int(50 * (y / self.alto))
            pygame.draw.line(fondo, (color_r, color_g, color_b), (0, y), (self.ancho, y))

        return fondo

    def inicializar_partida(self):
        """Inicializa una nueva partida"""
        # Crear jugadores
        modo_combos_infinitos = (self.modo_actual == ModoJuego.COMBOS_INFINITOS)

        self.jugador1 = Jugador(200, ALTO - 300, self.personaje_j1, True, modo_combos_infinitos)
        self.jugador2 = Jugador(ANCHO - 400, ALTO - 300, self.personaje_j2, False, modo_combos_infinitos)

        # Configurar plataformas seg√∫n modo
        self.plataformas = [
            Plataforma(0, ALTO - 50, ANCHO, 50),  # Plataforma principal
        ]

        # Agregar plataformas adicionales para modos espec√≠ficos
        if self.modo_actual == ModoJuego.CLASICO:
            self.plataformas.extend([
                Plataforma(ANCHO // 4 - 150, ALTO - 200, 300, 20),
                Plataforma(3 * ANCHO // 4 - 150, ALTO - 200, 300, 20)
            ])
        elif self.modo_actual == ModoJuego.SUPERVIVENCIA:
            # Plataformas m√°s desafiantes para supervivencia
            for i in range(4):
                x = (i + 1) * ANCHO // 5
                ancho = random.randint(100, 200)
                self.plataformas.append(Plataforma(x - ancho // 2, ALTO - 150 - i * 50, ancho, 15))

        # Resetear estad√≠sticas
        self.vidas_j1 = CONFIG_MODOS[self.modo_actual].get("vidas", 3)
        self.vidas_j2 = CONFIG_MODOS[self.modo_actual].get("vidas", 3)
        self.puntuacion_j1 = 0
        self.puntuacion_j2 = 0
        self.oleada_actual = 1
        self.tiempo_juego = 0

    def obtener_teclas(self):
        """Obtiene el estado de las teclas para ambos jugadores"""
        teclas = pygame.key.get_pressed()

        def tecla_presionada(key):
            return teclas[key] if key < len(teclas) else False

        return tecla_presionada

    def actualizar(self):
        """Actualiza el estado del juego"""
        if self.estado != EstadoJuego.JUGANDO:
            return

        self.tiempo_juego += 1
        self.tiempo_fondo += 0.01

        # Actualizar jugadores
        teclas = self.obtener_teclas()
        self.jugador1.actualizar(teclas, self.plataformas)
        self.jugador2.actualizar(teclas, self.plataformas)

        # Actualizar part√≠culas
        self.sistema_particulas.actualizar()

        # Verificar colisiones de ataque
        self.verificar_colisiones()

        # Verificar condiciones de victoria
        self.verificar_condiciones_victoria()

    def verificar_colisiones(self):
        """Verifica colisiones entre ataques y jugadores"""
        # Jugador 1 ataca a jugador 2
        if self.jugador1.hitbox_ataque and self.jugador1.hitbox_ataque.colliderect(self.jugador2.rect_colision):
            if not self.jugador2.esta_bloqueando:
                dano = self.jugador1.get_dano_ataque()
                if self.jugador2.recibir_dano(dano, self.sistema_particulas):
                    self.sistema_sonido.reproducir('impacto')
                    self.puntuacion_j1 += dano * 10

        # Jugador 2 ataca a jugador 1
        if self.jugador2.hitbox_ataque and self.jugador2.hitbox_ataque.colliderect(self.jugador1.rect_colision):
            if not self.jugador1.esta_bloqueando:
                dano = self.jugador2.get_dano_ataque()
                if self.jugador1.recibir_dano(dano, self.sistema_particulas):
                    self.sistema_sonido.reproducir('impacto')
                    self.puntuacion_j2 += dano * 10

    def verificar_condiciones_victoria(self):
        """Verifica las condiciones de victoria seg√∫n el modo"""
        if self.modo_actual == ModoJuego.CLASICO:
            # Verificar si un jugador se qued√≥ sin vida
            if self.jugador1.vida_actual <= 0:
                self.vidas_j1 -= 1
                if self.vidas_j1 > 0:
                    self.respawn_jugador(self.jugador1)
                else:
                    self.finalizar_partida("jugador2")

            if self.jugador2.vida_actual <= 0:
                self.vidas_j2 -= 1
                if self.vidas_j2 > 0:
                    self.respawn_jugador(self.jugador2)
                else:
                    self.finalizar_partida("jugador1")

        elif self.modo_actual == ModoJuego.SUPERVIVENCIA:
            # Modo supervivencia: jugador 1 vs oleadas
            if self.jugador1.vida_actual <= 0:
                self.finalizar_partida("derrota")

            # L√≥gica de oleadas (simplificada)
            if self.tiempo_juego % 1800 == 0:  # Cada 30 segundos
                self.oleada_actual += 1
                self.jugador2.curar(50)  # El enemigo se cura cada oleada

        elif self.modo_actual == ModoJuego.COMBOS_INFINITOS:
            # Combos infinitos: por tiempo o por vida
            if self.jugador1.vida_actual <= 0:
                self.vidas_j1 -= 1
                if self.vidas_j1 > 0:
                    self.respawn_jugador(self.jugador1)
                else:
                    self.finalizar_partida("jugador2")

            if self.jugador2.vida_actual <= 0:
                self.vidas_j2 -= 1
                if self.vidas_j2 > 0:
                    self.respawn_jugador(self.jugador2)
                else:
                    self.finalizar_partida("jugador1")

    def respawn_jugador(self, jugador):
        """Hace respawn de un jugador"""
        if jugador.es_jugador1:
            jugador.x = 200
        else:
            jugador.x = ANCHO - 400

        jugador.y = ALTO - 300
        jugador.vida_actual = jugador.vida_maxima
        jugador.velocidad_y = 0
        jugador.invencible = True
        jugador.tiempo_invencibilidad = pygame.time.get_ticks() + 2000
        jugador.estado_animacion = "idle"

    def finalizar_partida(self, resultado):
        """Finaliza la partida actual"""
        self.estado = EstadoJuego.GAME_OVER
        self.resultado_partida = resultado

        # Guardar progresi√≥n
        if resultado == "jugador1":
            self.sistema_progresion.ganar_experiencia(
                self.personaje_j1, 100, self.jugador1.mejor_combo, True
            )
        elif resultado == "jugador2":
            self.sistema_progresion.ganar_experiencia(
                self.personaje_j2, 100, self.jugador2.mejor_combo, True
            )

        self.sistema_sonido.reproducir('victoria' if resultado != "derrota" else 'derrota')

    def dibujar(self):
        """Dibuja el juego completo"""
        # Dibujar fondo seg√∫n estado
        if self.estado == EstadoJuego.MENU:
            self.menu_principal.dibujar(ventana, self.sistema_sonido)

        elif self.estado == EstadoJuego.SELECCION_MODO:
            self.menu_seleccion_modo.dibujar(ventana)

        elif self.estado == EstadoJuego.SELECCION_PERSONAJE:
            self.menu_seleccion_personaje.dibujar(ventana, self.sistema_sonido)

        elif self.estado == EstadoJuego.CONTROLES:
            self.menu_controles.dibujar(ventana)

        elif self.estado == EstadoJuego.JUGANDO:
            # Fondo animado
            self.dibujar_fondo_animado()

            # Dibujar plataformas
            for plataforma in self.plataformas:
                plataforma.dibujar(ventana)

            # Dibujar part√≠culas
            self.sistema_particulas.dibujar(ventana)

            # Dibujar jugadores
            self.jugador1.dibujar(ventana)
            self.jugador2.dibujar(ventana)

            # Dibujar interfaz
            self.dibujar_interfaz()

        elif self.estado == EstadoJuego.GAME_OVER:
            # Dibujar juego pausado
            self.dibujar_fondo_animado()
            for plataforma in self.plataformas:
                plataforma.dibujar(ventana)
            self.sistema_particulas.dibujar(ventana)
            self.jugador1.dibujar(ventana)
            self.jugador2.dibujar(ventana)
            self.dibujar_interfaz()

            # Superposici√≥n de game over
            overlay = pygame.Surface((ANCHO, ALTO), pygame.SRCALPHA)
            overlay.fill((0, 0, 0, 180))
            ventana.blit(overlay, (0, 0))

            self.dibujar_pantalla_game_over()

        # Mostrar FPS si est√° activado
        if self.mostrar_fps:
            self.dibujar_fps()

    def dibujar_fondo_animado(self):
        """Dibuja un fondo animado"""
        # Actualizar fondo con animaci√≥n
        tiempo = pygame.time.get_ticks() / 1000

        # Gradiente animado - CORREGIDO: asegurar valores entre 0-255
        for y in range(self.alto):
            # Calcular valores de seno
            sin_val1 = math.sin(y / 100 + tiempo * 0.5)
            sin_val2 = math.sin(y / 150 + tiempo * 0.7)
            sin_val3 = math.sin(y / 200 + tiempo)

            # Asegurar que los valores est√©n entre 0-255
            color_r = max(0, min(255, 20 + int(30 * sin_val1)))
            color_g = max(0, min(255, 25 + int(40 * sin_val2)))
            color_b = max(0, min(255, 40 + int(50 * sin_val3)))

            pygame.draw.line(ventana, (color_r, color_g, color_b), (0, y), (self.ancho, y))

        # Estrellas/part√≠culas de fondo
        for i in range(50):
            x = (tiempo * 20 + i * 73) % (self.ancho + 100) - 50
            y = (self.alto // 3 + math.sin(tiempo + i * 0.5) * 100) % self.alto
            tama√±o = 1 + abs(math.sin(tiempo * 2 + i)) * 0.5
            brillo = max(0, min(255, 150 + int(50 * math.sin(tiempo + i))))
            pygame.draw.circle(ventana, (brillo, brillo, brillo), (int(x), int(y)), int(tama√±o))

    def dibujar_interfaz(self):
        """Dibuja la interfaz de usuario durante el juego"""
        # Panel superior
        panel_rect = pygame.Rect(0, 0, ANCHO, 80)
        pygame.draw.rect(ventana, (0, 0, 0, 150), panel_rect)
        pygame.draw.line(ventana, (100, 100, 200), (0, 80), (ANCHO, 80), 2)

        # Informaci√≥n jugador 1 (izquierda)
        fuente = pygame.font.SysFont('Arial', 24, bold=True)

        # Nombre y vidas J1
        texto_j1 = fuente.render(f"J1: {CLASES_PERSONAJE[self.personaje_j1]['nombre']}",
                                 True, (100, 200, 255))
        ventana.blit(texto_j1, (20, 20))

        # Vidas J1
        for i in range(self.vidas_j1):
            x = 20 + i * 30
            y = 50
            pygame.draw.circle(ventana, (100, 200, 255), (x, y), 10)
            pygame.draw.circle(ventana, (255, 255, 255), (x, y), 10, 2)

        # Puntuaci√≥n J1
        puntuacion_j1 = fuente.render(f"Puntos: {self.puntuacion_j1}", True, (200, 200, 200))
        ventana.blit(puntuacion_j1, (20 + self.vidas_j1 * 30 + 20, 45))

        # Informaci√≥n jugador 2 (derecha)
        texto_j2 = fuente.render(f"J2: {CLASES_PERSONAJE[self.personaje_j2]['nombre']}",
                                 True, (255, 100, 100))
        ventana.blit(texto_j2, (ANCHO - texto_j2.get_width() - 20, 20))

        # Vidas J2
        for i in range(self.vidas_j2):
            x = ANCHO - 20 - (self.vidas_j2 - i) * 30
            y = 50
            pygame.draw.circle(ventana, (255, 100, 100), (x, y), 10)
            pygame.draw.circle(ventana, (255, 255, 255), (x, y), 10, 2)

        # Puntuaci√≥n J2
        puntuacion_j2 = fuente.render(f"Puntos: {self.puntuacion_j2}", True, (200, 200, 200))
        ventana.blit(puntuacion_j2, (ANCHO - puntuacion_j2.get_width() - 20 - self.vidas_j2 * 30 - 20, 45))

        # Informaci√≥n del modo en el centro
        if self.modo_actual:
            info_modo = CONFIG_MODOS[self.modo_actual]

            # Nombre del modo
            modo_texto = fuente.render(info_modo["nombre"], True, info_modo["color"])
            ventana.blit(modo_texto, (ANCHO // 2 - modo_texto.get_width() // 2, 20))

            # Informaci√≥n espec√≠fica del modo
            info_texto = ""
            if self.modo_actual == ModoJuego.SUPERVIVENCIA:
                info_texto = f"Oleada: {self.oleada_actual}"
            elif self.modo_actual == ModoJuego.COMBOS_INFINITOS:
                mejor_combo = max(self.jugador1.mejor_combo, self.jugador2.mejor_combo)
                info_texto = f"Mejor Combo: {mejor_combo}"
            else:  # Cl√°sico
                info_texto = f"Tiempo: {self.tiempo_juego // 60}:{self.tiempo_juego % 60:02d}"

            info_render = pygame.font.SysFont('Arial', 20).render(info_texto, True, (200, 200, 200))
            ventana.blit(info_render, (ANCHO // 2 - info_render.get_width() // 2, 50))

        # Instrucciones en la parte inferior
        fuente_inst = pygame.font.SysFont('Arial', 18)
        instrucciones = fuente_inst.render("ESC: Men√∫  |  F1: Mostrar/Ocultar FPS  |  F11: Pantalla completa",
                                           True, (150, 150, 150))
        ventana.blit(instrucciones, (ANCHO // 2 - instrucciones.get_width() // 2, ALTO - 30))

    def dibujar_pantalla_game_over(self):
        """Dibuja la pantalla de game over"""
        # Panel central
        panel_ancho = 600
        panel_alto = 400
        panel_rect = pygame.Rect(ANCHO // 2 - panel_ancho // 2,
                                 ALTO // 2 - panel_alto // 2,
                                 panel_ancho, panel_alto)

        pygame.draw.rect(ventana, (40, 40, 80), panel_rect, border_radius=20)
        pygame.draw.rect(ventana, (100, 100, 200), panel_rect, 4, border_radius=20)

        # T√≠tulo
        fuente_titulo = pygame.font.SysFont('Arial', 48, bold=True)

        if self.resultado_partida == "jugador1":
            titulo_texto = "üèÜ ¬°JUGADOR 1 GANA!"
            color_titulo = (100, 200, 255)
        elif self.resultado_partida == "jugador2":
            titulo_texto = "üèÜ ¬°JUGADOR 2 GANA!"
            color_titulo = (255, 100, 100)
        else:
            titulo_texto = "üíÄ GAME OVER"
            color_titulo = (200, 200, 200)

        titulo = fuente_titulo.render(titulo_texto, True, color_titulo)
        ventana.blit(titulo, (ANCHO // 2 - titulo.get_width() // 2, panel_rect.top + 40))

        # Estad√≠sticas
        fuente_stats = pygame.font.SysFont('Arial', 24)
        y_stats = panel_rect.top + 120

        estadisticas = [
            f"Modo: {CONFIG_MODOS[self.modo_actual]['nombre']}",
            f"Duraci√≥n: {self.tiempo_juego // 60}:{self.tiempo_juego % 60:02d}",
            f"Puntos J1: {self.puntuacion_j1}",
            f"Puntos J2: {self.puntuacion_j2}",
            f"Mejor Combo J1: {self.jugador1.mejor_combo}",
            f"Mejor Combo J2: {self.jugador2.mejor_combo}"
        ]

        for stat in estadisticas:
            stat_text = fuente_stats.render(stat, True, (200, 200, 200))
            ventana.blit(stat_text, (panel_rect.centerx - stat_text.get_width() // 2, y_stats))
            y_stats += 40

        # Botones
        y_botones = panel_rect.bottom - 100

        boton_revancha = Boton(panel_rect.centerx - 150, y_botones, 140, 50,
                               "üîÑ REVANCHA", (100, 150, 255), (150, 200, 255))
        boton_menu = Boton(panel_rect.centerx + 10, y_botones, 140, 50,
                           "üè† MEN√ö", (200, 100, 100), (255, 150, 150))

        pos_mouse = pygame.mouse.get_pos()
        boton_revancha.actualizar(pos_mouse)
        boton_menu.actualizar(pos_mouse)

        boton_revancha.dibujar(ventana)
        boton_menu.dibujar(ventana)

        # Instrucciones
        fuente_inst = pygame.font.SysFont('Arial', 18)
        instrucciones = fuente_inst.render("Haz clic en un bot√≥n o presiona R para revancha / ESC para men√∫",
                                           True, (150, 150, 150))
        ventana.blit(instrucciones, (ANCHO // 2 - instrucciones.get_width() // 2, panel_rect.bottom - 40))

        # Manejar clics en los botones
        for evento in pygame.event.get(pygame.MOUSEBUTTONDOWN):
            if evento.button == 1:
                if boton_revancha.rect.collidepoint(evento.pos):
                    self.sistema_sonido.reproducir('menu_select')
                    self.inicializar_partida()
                    self.estado = EstadoJuego.JUGANDO
                elif boton_menu.rect.collidepoint(evento.pos):
                    self.sistema_sonido.reproducir('menu_select')
                    self.estado = EstadoJuego.MENU

    def dibujar_fps(self):
        """Dibuja el contador de FPS"""
        fps = int(self.clock.get_fps())
        fuente = pygame.font.SysFont('Arial', 20, bold=True)
        texto = fuente.render(f"FPS: {fps}", True,
                              (100, 255, 100) if fps >= 50 else (255, 255, 100) if fps >= 30 else (255, 100, 100))
        ventana.blit(texto, (ANCHO - texto.get_width() - 10, 10))

    def ejecutar(self):
        """Bucle principal del juego"""
        ejecutando = True

        while ejecutando:
            # Manejar eventos
            eventos = pygame.event.get()

            for evento in eventos:
                if evento.type == pygame.QUIT:
                    ejecutando = False

                elif evento.type == pygame.KEYDOWN:
                    # Teclas globales
                    if evento.key == pygame.K_ESCAPE:
                        if self.estado == EstadoJuego.JUGANDO:
                            self.estado = EstadoJuego.MENU
                        elif self.estado == EstadoJuego.GAME_OVER:
                            self.estado = EstadoJuego.MENU
                        else:
                            ejecutando = False

                    elif evento.key == pygame.K_F1:
                        self.mostrar_fps = not self.mostrar_fps

                    elif evento.key == pygame.K_F11:
                        # Alternar pantalla completa
                        pygame.display.toggle_fullscreen()

                    elif evento.key == pygame.K_F12:
                        # Capturar pantalla
                        self.capturar_pantalla()

                    # Teclas para game over
                    elif evento.key == pygame.K_r and self.estado == EstadoJuego.GAME_OVER:
                        self.sistema_sonido.reproducir('menu_select')
                        self.inicializar_partida()
                        self.estado = EstadoJuego.JUGANDO

            # Manejar estado actual
            if self.estado == EstadoJuego.MENU:
                resultado = self.menu_principal.manejar_eventos(eventos, self.sistema_sonido)
                if resultado == "jugar":
                    self.estado = EstadoJuego.SELECCION_MODO
                elif resultado == "opciones":
                    # Por simplicidad, vamos directo a controles
                    self.estado = EstadoJuego.CONTROLES
                elif resultado == "controles":
                    self.estado = EstadoJuego.CONTROLES
                elif resultado == "salir":
                    ejecutando = False

            elif self.estado == EstadoJuego.SELECCION_MODO:
                resultado = self.menu_seleccion_modo.manejar_eventos(eventos, self.sistema_sonido)
                if isinstance(resultado, ModoJuego):
                    self.modo_actual = resultado
                    self.estado = EstadoJuego.SELECCION_PERSONAJE
                elif resultado == "menu":
                    self.estado = EstadoJuego.MENU

            elif self.estado == EstadoJuego.SELECCION_PERSONAJE:
                resultado = self.menu_seleccion_personaje.manejar_eventos(eventos, self.sistema_sonido)
                if resultado and resultado[0] == "empezar":
                    self.personaje_j1 = resultado[1]
                    self.personaje_j2 = resultado[2]
                    self.inicializar_partida()
                    self.estado = EstadoJuego.JUGANDO
                elif resultado == "menu":
                    self.estado = EstadoJuego.MENU

            elif self.estado == EstadoJuego.CONTROLES:
                resultado = self.menu_controles.manejar_eventos(eventos, self.sistema_sonido)
                if resultado == "menu":
                    self.estado = EstadoJuego.MENU

            elif self.estado == EstadoJuego.JUGANDO:
                # Actualizar juego
                self.actualizar()

            # Dibujar
            self.dibujar()

            # Actualizar pantalla
            pygame.display.flip()

            # Controlar FPS
            self.clock.tick(self.fps)

        pygame.quit()
        sys.exit()

    def capturar_pantalla(self):
        """Captura la pantalla actual y la guarda en un archivo"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"captura_{timestamp}.png"
            pygame.image.save(ventana, filename)
            print(f"‚úÖ Captura guardada como {filename}")
        except Exception as e:
            print(f"‚ùå Error al guardar captura: {e}")


# =============================================================================
# PUNTO DE ENTRADA
# =============================================================================

if __name__ == "__main__":
    print("=" * 60)
    print("üéÆ STICK MAN ARENA - EDICI√ìN Baruc")
    print("=" * 60)
    print("‚ú® Caracter√≠sticas principales:")
    print("   ‚Ä¢ 4 personajes √∫nicos con habilidades especiales")
    print("   ‚Ä¢ 3 modos de juego: Cl√°sico, Supervivencia, Combos Infinitos")
    print("   ‚Ä¢ Sistema de progresi√≥n y niveles")
    print("   ‚Ä¢ Gr√°ficos din√°micos y efectos visuales")
    print("   ‚Ä¢ Sistema de sonido procedural")
    print("   ‚Ä¢ Controles mejorados y personalizables")
    print("   ‚Ä¢ Interfaz de usuario moderna y atractiva")
    print("=" * 60)

    # Crear y ejecutar juego
    juego = Juego()
    juego.ejecutar()
